<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ–• Hand Particle Tracker</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;font-family:'Segoe UI',Arial,sans-serif}
        #video{position:fixed;bottom:15px;right:15px;width:220px;height:165px;border:1px solid #222;border-radius:8px;z-index:20;transform:scaleX(-1);object-fit:cover;opacity:.9}
        #debugCanvas{position:fixed;bottom:15px;left:15px;width:220px;height:165px;border:1px solid #333;border-radius:8px;z-index:20;background:#000}
        #status{position:fixed;top:15px;left:50%;transform:translateX(-50%);color:#555;font-size:13px;z-index:30;text-align:center;background:rgba(0,0,0,.85);padding:8px 18px;border-radius:20px;border:1px solid #222;letter-spacing:.5px;transition:all .3s}
        #status.active{color:#ff2020;border-color:#ff2020;box-shadow:0 0 25px rgba(255,30,30,.4)}
        #status.hand{color:#ff8800;border-color:#ff8800;box-shadow:0 0 15px rgba(255,136,0,.3)}
        #flash{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;opacity:0;transition:opacity .15s}
        #flash.spawn{opacity:1;background:radial-gradient(circle,rgba(255,60,20,.3),transparent 70%);transition:opacity .03s}
        #flash.explode{opacity:1;background:radial-gradient(circle,rgba(255,255,255,.5),rgba(255,40,20,.3) 40%,transparent 70%);transition:opacity .03s}
        #vignette{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:4;background:radial-gradient(ellipse at center,transparent 50%,rgba(0,0,0,.7))}
        .loading{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#666;font-size:16px;z-index:100;text-align:center}
        .spinner{border:2px solid #1a1a1a;border-top:2px solid #ff2020;border-radius:50%;width:32px;height:32px;animation:s .8s linear infinite;margin:12px auto}
        @keyframes s{to{transform:rotate(360deg)}}
    </style>
</head>
<body>
    <div id="loadingScreen" class="loading"><div class="spinner"></div><p>Loading hand tracking...</p></div>
    <div id="vignette"></div>
    <div id="flash"></div>
    <video id="video" autoplay playsinline></video>
    <canvas id="debugCanvas"></canvas>
    <div id="status">Show your hand âœ‹</div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    (function(){
        const video=document.getElementById('video');
        const statusEl=document.getElementById('status');
        const loadingScreen=document.getElementById('loadingScreen');
        const flashEl=document.getElementById('flash');
        const dbgCanvas=document.getElementById('debugCanvas');
        const dbgCtx=dbgCanvas.getContext('2d');
        dbgCanvas.width=320;dbgCanvas.height=240;

        let shakeAmount=0;
        function screenShake(a){shakeAmount=Math.max(shakeAmount,a)}
        function doFlash(type){flashEl.className='';void flashEl.offsetWidth;flashEl.classList.add(type);setTimeout(()=>flashEl.className='',200)}

        // THREE
        const scene=new THREE.Scene();
        scene.background=new THREE.Color(0x000000);
        const camera=new THREE.PerspectiveCamera(50,innerWidth/innerHeight,.1,800);
        camera.position.set(0,0,50);
        const renderer=new THREE.WebGLRenderer({antialias:false});
        renderer.setSize(innerWidth,innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio,2));
        document.body.prepend(renderer.domElement);
        window.addEventListener('resize',()=>{
            camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();
            renderer.setSize(innerWidth,innerHeight);
            rtMain.setSize(innerWidth,innerHeight);
            rtA.setSize(Math.floor(innerWidth/4),Math.floor(innerHeight/4));
            rtB.setSize(Math.floor(innerWidth/4),Math.floor(innerHeight/4));
        });

        scene.add(new THREE.AmbientLight(0xffffff,.4));

        // Bloom
        const ortho=new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        const rtp={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};
        let rtA=new THREE.WebGLRenderTarget(Math.floor(innerWidth/4),Math.floor(innerHeight/4),rtp);
        let rtB=new THREE.WebGLRenderTarget(Math.floor(innerWidth/4),Math.floor(innerHeight/4),rtp);
        let rtMain=new THREE.WebGLRenderTarget(innerWidth,innerHeight,rtp);
        const blurMat=new THREE.ShaderMaterial({
            uniforms:{tDiffuse:{value:null},direction:{value:new THREE.Vector2()},resolution:{value:new THREE.Vector2()}},
            vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.);}`,
            fragmentShader:`uniform sampler2D tDiffuse;uniform vec2 direction,resolution;varying vec2 vUv;
            void main(){vec2 o=direction/resolution;vec4 c=texture2D(tDiffuse,vUv)*.2;
            for(float i=1.;i<=4.;i++){float w=.2/i;c+=texture2D(tDiffuse,vUv+i*o)*w;c+=texture2D(tDiffuse,vUv-i*o)*w;}
            gl_FragColor=c;}`
        });
        const compMat=new THREE.ShaderMaterial({
            uniforms:{tScene:{value:null},tBloom:{value:null},bloomStrength:{value:2.}},
            vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.);}`,
            fragmentShader:`uniform sampler2D tScene,tBloom;uniform float bloomStrength;varying vec2 vUv;
            void main(){gl_FragColor=texture2D(tScene,vUv)+texture2D(tBloom,vUv)*bloomStrength;}`
        });
        const fsGeo=new THREE.PlaneGeometry(2,2);
        const blurQ=new THREE.Mesh(fsGeo,blurMat);const blurSc=new THREE.Scene();blurSc.add(blurQ);
        const compQ=new THREE.Mesh(fsGeo,compMat);const compSc=new THREE.Scene();compSc.add(compQ);
        function renderBloom(){
            renderer.setRenderTarget(rtMain);renderer.render(scene,camera);
            blurMat.uniforms.resolution.value.set(rtA.width,rtA.height);
            blurMat.uniforms.tDiffuse.value=rtMain.texture;blurMat.uniforms.direction.value.set(2,0);
            renderer.setRenderTarget(rtA);renderer.render(blurSc,ortho);
            blurMat.uniforms.tDiffuse.value=rtA.texture;blurMat.uniforms.direction.value.set(0,2);
            renderer.setRenderTarget(rtB);renderer.render(blurSc,ortho);
            blurMat.uniforms.tDiffuse.value=rtB.texture;blurMat.uniforms.direction.value.set(1.5,0);
            renderer.setRenderTarget(rtA);renderer.render(blurSc,ortho);
            blurMat.uniforms.tDiffuse.value=rtA.texture;blurMat.uniforms.direction.value.set(0,1.5);
            renderer.setRenderTarget(rtB);renderer.render(blurSc,ortho);
            compMat.uniforms.tScene.value=rtMain.texture;compMat.uniforms.tBloom.value=rtB.texture;
            renderer.setRenderTarget(null);renderer.render(compSc,ortho);
        }

        // Instanced cubes â€” use vertexColors
        const GEO=new THREE.BoxGeometry(.35,.35,.35);
        const MAT=new THREE.MeshBasicMaterial({vertexColors:false});
        const MAX=50000;
        const imesh=new THREE.InstancedMesh(GEO,MAT,MAX);
        imesh.count=0;scene.add(imesh);
        // Force instanceColor buffer creation
        const initColor=new THREE.Color(1,0,0);
        for(let i=0;i<100;i++)imesh.setColorAt(i,initColor);
        imesh.instanceColor.needsUpdate=true;
        imesh.count=0;

        const dum=new THREE.Object3D();
        const tc=new THREE.Color();

        const fingerLight=new THREE.PointLight(0xff4400,0,120);scene.add(fingerLight);
        const fingerLight2=new THREE.PointLight(0xff2200,0,80);scene.add(fingerLight2);

        // â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const P=[];
        function addP(o){
            if(P.length>=MAX)return null;
            const p={x:o.x||0,y:o.y||0,z:o.z||0,vx:o.vx||0,vy:o.vy||0,vz:o.vz||0,
                r:o.r||1,g:o.g||.1,b:o.b||.02,size:o.size||.5,life:o.life||1,maxLife:o.life||1,
                decay:o.decay||.01,grav:o.grav||0,type:o.type||'fx',
                spin:(Math.random()-.5)*.1,rotX:Math.random()*6.28,rotY:Math.random()*6.28,
                shimmer:Math.random()*6.28,
                // For hand tracking particles
                jointIdx:o.jointIdx||-1,
                localOff:o.localOff||{x:0,y:0,z:0},
                baseR:o.r||1,baseG:o.g||.1,baseB:o.b||.02};
            P.push(p);return p;
        }

        // â”€â”€ COLOR PALETTES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function hotColor(temp){
            // temp 0=cool red, 1=white hot
            const t=Math.max(0,Math.min(1,temp));
            return{
                r:.7+t*.3,
                g:.02+t*.9,
                b:.01+t*.95
            };
        }
        function randomRed(){
            const t=Math.random();
            if(t<.3)return{r:.9+Math.random()*.1,g:.02+Math.random()*.06,b:.01+Math.random()*.02};
            if(t<.55)return{r:.95+Math.random()*.05,g:.1+Math.random()*.15,b:.01+Math.random()*.03};
            if(t<.75)return{r:1,g:.2+Math.random()*.2,b:.02+Math.random()*.05};
            if(t<.9)return{r:1,g:.4+Math.random()*.25,b:.03+Math.random()*.08};
            return{r:1,g:.7+Math.random()*.3,b:.3+Math.random()*.5};
        }
        function boneColor(idx){
            // Different colors for different finger bones
            // 0-4: thumb (orange)
            // 5-8: index (red-orange)
            // 9-12: middle (bright red / white hot)
            // 13-16: ring (deep red)
            // 17-20: pinky (dark red)
            if(idx<=4)return{r:1,g:.35+Math.random()*.2,b:.02+Math.random()*.05};
            if(idx<=8)return{r:1,g:.15+Math.random()*.15,b:.01+Math.random()*.03};
            if(idx<=12)return{r:1,g:.5+Math.random()*.4,b:.2+Math.random()*.5};
            if(idx<=16)return{r:.85+Math.random()*.15,g:.04+Math.random()*.06,b:.01+Math.random()*.02};
            return{r:.7+Math.random()*.15,g:.02+Math.random()*.04,b:.02+Math.random()*.03};
        }

        // â”€â”€ HAND SKELETON CONNECTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const BONES=[
            [0,1],[1,2],[2,3],[3,4],       // thumb
            [0,5],[5,6],[6,7],[7,8],       // index
            [0,9],[9,10],[10,11],[11,12],  // middle
            [0,13],[13,14],[14,15],[15,16],// ring
            [0,17],[17,18],[18,19],[19,20],// pinky
            [5,9],[9,13],[13,17]           // palm
        ];

        // â”€â”€ HAND PARTICLE SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // We maintain a pool of particles that represent the hand skeleton
        let handParticles=[];
        let handActive=false;
        let middleFingerDetected=false;
        let middleFingerGroup=null;
        let prevLandmarks=null;
        let smoothLandmarks=null;

        // Convert normalized landmark to world coords
        function lmToWorld(lm){
            return{
                x:(1-lm.x-.5)*55,
                y:(.5-lm.y)*42,
                z:(lm.z||0)*-30
            };
        }

        function initHandParticles(){
            handParticles=[];
            // For each bone, create particles along it
            // For each joint, create a cluster
            // Total: joints (21 clusters) + bones (lines between)
        }

        function updateHandTracking(landmarks){
            if(!smoothLandmarks){
                smoothLandmarks=landmarks.map(l=>({x:l.x,y:l.y,z:l.z||0}));
            }else{
                for(let i=0;i<21;i++){
                    smoothLandmarks[i].x+=(landmarks[i].x-smoothLandmarks[i].x)*.35;
                    smoothLandmarks[i].y+=(landmarks[i].y-smoothLandmarks[i].y)*.35;
                    smoothLandmarks[i].z+=((landmarks[i].z||0)-smoothLandmarks[i].z)*.35;
                }
            }

            const lm=smoothLandmarks;
            const worldPts=lm.map(l=>lmToWorld(l));

            // Joint particles - clusters at each joint
            for(let ji=0;ji<21;ji++){
                const wp=worldPts[ji];
                const col=boneColor(ji);
                const isFingerTip=[4,8,12,16,20].includes(ji);
                const clusterSize=isFingerTip?5:3;

                for(let c=0;c<clusterSize;c++){
                    const off={
                        x:(Math.random()-.5)*.8,
                        y:(Math.random()-.5)*.8,
                        z:(Math.random()-.5)*.8
                    };
                    addP({x:wp.x+off.x,y:wp.y+off.y,z:wp.z+off.z,
                        r:col.r,g:col.g,b:col.b,
                        size:.3+Math.random()*.2,
                        life:.15,decay:1,grav:0,type:'hand'});
                }

                // Fingertip sparks
                if(isFingerTip&&Math.random()<.3){
                    const sc=randomRed();
                    addP({x:wp.x,y:wp.y,z:wp.z,
                        vx:(Math.random()-.5)*.5,vy:.3+Math.random()*.5,vz:(Math.random()-.5)*.5,
                        r:sc.r,g:sc.g,b:sc.b,
                        size:.12+Math.random()*.08,
                        life:.8+Math.random()*.6,decay:.02,grav:.005,type:'spark'});
                }
            }

            // Bone particles - along each bone
            for(const[a,b]of BONES){
                const wa=worldPts[a],wb=worldPts[b];
                const dist=Math.sqrt((wa.x-wb.x)**2+(wa.y-wb.y)**2+(wa.z-wb.z)**2);
                const steps=Math.max(2,Math.floor(dist/.8));
                const isMiddleBone=([9,10,11,12].includes(a)&&[9,10,11,12].includes(b));

                for(let s=0;s<=steps;s++){
                    const t=s/steps;
                    const px=wa.x+(wb.x-wa.x)*t+(Math.random()-.5)*.3;
                    const py=wa.y+(wb.y-wa.y)*t+(Math.random()-.5)*.3;
                    const pz=wa.z+(wb.z-wa.z)*t+(Math.random()-.5)*.3;

                    const col=isMiddleBone&&middleFingerDetected?
                        {r:1,g:.5+Math.random()*.5,b:.3+Math.random()*.6}:
                        boneColor(Math.min(a,b));

                    addP({x:px,y:py,z:pz,
                        r:col.r,g:col.g,b:col.b,
                        size:isMiddleBone&&middleFingerDetected?.35+Math.random()*.15:.22+Math.random()*.1,
                        life:.12,decay:1,grav:0,type:'hand'});
                }

                // Motion trails along bones
                if(prevLandmarks&&Math.random()<.15){
                    const prevWa=lmToWorld(prevLandmarks[a]);
                    const vel={
                        x:(wa.x-prevWa.x)*2,
                        y:(wa.y-prevWa.y)*2,
                        z:(wa.z-prevWa.z)*2
                    };
                    const speed=Math.sqrt(vel.x*vel.x+vel.y*vel.y+vel.z*vel.z);
                    if(speed>.3){
                        const sc=randomRed();
                        addP({x:wa.x,y:wa.y,z:wa.z,
                            vx:-vel.x*.3+(Math.random()-.5)*.2,
                            vy:-vel.y*.3+(Math.random()-.5)*.2,
                            vz:-vel.z*.3+(Math.random()-.5)*.2,
                            r:sc.r,g:sc.g,b:sc.b,
                            size:.1+Math.random()*.08,
                            life:.5+Math.random()*.5,decay:.025,grav:.002,type:'trail'});
                    }
                }
            }

            // Palm fill
            const palmIndices=[0,5,9,13,17];
            const palmCenter={x:0,y:0,z:0};
            for(const pi of palmIndices){
                palmCenter.x+=worldPts[pi].x;
                palmCenter.y+=worldPts[pi].y;
                palmCenter.z+=worldPts[pi].z;
            }
            palmCenter.x/=5;palmCenter.y/=5;palmCenter.z/=5;

            for(let i=0;i<8;i++){
                const angle=Math.random()*Math.PI*2;
                const rad=Math.random()*3;
                const col=randomRed();
                addP({
                    x:palmCenter.x+Math.cos(angle)*rad,
                    y:palmCenter.y+Math.sin(angle)*rad*(palmCenter.y>0?.8:1),
                    z:palmCenter.z+(Math.random()-.5)*1.5,
                    r:col.r*.6,g:col.g*.6,b:col.b*.6,
                    size:.18+Math.random()*.1,life:.1,decay:1,grav:0,type:'hand'
                });
            }

            // Ambient heat shimmer around hand
            if(Math.random()<.4){
                const ri=Math.floor(Math.random()*21);
                const wp=worldPts[ri];
                const sc=randomRed();
                addP({x:wp.x+(Math.random()-.5)*2,y:wp.y+(Math.random()-.5)*2,z:wp.z+(Math.random()-.5)*2,
                    vx:(Math.random()-.5)*.1,vy:.15+Math.random()*.2,vz:(Math.random()-.5)*.1,
                    r:sc.r*.5,g:sc.g*.5,b:sc.b*.5,
                    size:.08+Math.random()*.06,life:.6+Math.random()*.5,decay:.02,grav:-.002,type:'heat'});
            }

            prevLandmarks=landmarks.map(l=>({x:l.x,y:l.y,z:l.z||0}));

            // Update lights
            fingerLight.position.set(palmCenter.x,palmCenter.y+5,palmCenter.z+10);
            fingerLight2.position.set(worldPts[12].x,worldPts[12].y,worldPts[12].z+8);
        }

        // â”€â”€ MIDDLE FINGER 3D MODEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function buildFingerModel(){
            const pts=[];
            function cyl(cx,cy,cz,rad,h,step,seg){
                for(let y=0;y<h;y+=step){const r=rad*(1-(y/h)*.12);
                    for(let i=0;i<seg;i++){const a=(i/seg)*Math.PI*2;pts.push({x:cx+Math.cos(a)*r,y:cy+y,z:cz+Math.sin(a)*r})}
                    if(Math.floor(y*10)%3===0)for(let i=0;i<seg-3;i++){const a=(i/(seg-3))*Math.PI*2;pts.push({x:cx+Math.cos(a)*r*.4,y:cy+y,z:cz+Math.sin(a)*r*.4})}
                }
            }
            function hemi(cx,cy,cz,rad,seg){
                for(let p=0;p<Math.PI/2;p+=.25){const r=rad*Math.cos(p);const n=Math.max(3,Math.round(seg*Math.cos(p)));
                    for(let i=0;i<n;i++){const a=(i/n)*Math.PI*2;pts.push({x:cx+Math.cos(a)*r,y:cy+Math.sin(p)*rad,z:cz+Math.sin(a)*r})}}
            }
            function box(cx,cy,cz,w,h,d,step){
                for(let y=0;y<=h;y+=step){for(let x=-w/2;x<=w/2;x+=step){pts.push({x:cx+x,y:cy+y,z:cz+d/2});pts.push({x:cx+x,y:cy+y,z:cz-d/2})}
                    for(let z=-d/2;z<=d/2;z+=step){pts.push({x:cx-w/2,y:cy+y,z:cz+z});pts.push({x:cx+w/2,y:cy+y,z:cz+z})}}
            }
            cyl(0,5.5,0,1.15,14.5,.5,10);hemi(0,20,0,1.15,10);
            box(0,0,0,8.5,5.5,3.5,.7);
            for(const fx of[-3,-1,1,3])for(let t=0;t<=1;t+=.07){const a=t*Math.PI*.75;
                for(let i=0;i<5;i++){const ang=(i/5)*Math.PI*2;pts.push({x:fx+Math.cos(ang)*.5,y:5.5+Math.sin(a)*1.5+Math.sin(ang)*.55,z:Math.cos(a)*1.5-.5})}}
            for(let t=0;t<=1;t+=.05){const tx=4.75+Math.sin(t*1.2)*1.5;const ty=.8+t*3.8;const tz=1.75*(1-t*.6)+.5;
                for(let i=0;i<5;i++){const a=(i/5)*Math.PI*2;pts.push({x:tx+Math.cos(a)*.6,y:ty,z:tz+Math.sin(a)*.6})}}
            return pts;
        }
        const FINGER_MODEL=buildFingerModel();

        let mfParticles=[];
        let mfState='none'; // none, forming, alive, exploding
        let mfTimer=0;
        let mfCenter=new THREE.Vector3();
        let mfWorldPos={x:0,y:0,z:0};
        let mfAngle=0;

        function spawnMiddleFinger(wx,wy,wz,angle){
            mfParticles=[];
            mfState='forming';
            mfTimer=0;
            mfWorldPos={x:wx,y:wy,z:wz};
            mfAngle=angle;

            const ca=Math.cos(angle),sa=Math.sin(angle);

            for(const pt of FINGER_MODEL){
                if(P.length>=MAX-2000)break;
                const h=(pt.y+3)/25;
                const t=Math.random();
                let col;
                if(t<.3)col={r:.9+Math.random()*.1,g:.02+h*.12,b:.01};
                else if(t<.55)col={r:1,g:.12+h*.25,b:.01+Math.random()*.03};
                else if(t<.8)col={r:1,g:.3+h*.35,b:.02+Math.random()*.06};
                else col={r:1,g:.65+Math.random()*.35,b:.3+Math.random()*.5};

                const rx=pt.x*ca-pt.y*sa;
                const ry=pt.x*sa+pt.y*ca;

                const p=addP({
                    x:wx+rx+(Math.random()-.5)*40,
                    y:wy+ry+(Math.random()-.5)*40,
                    z:wz+pt.z+(Math.random()-.5)*40,
                    r:col.r,g:col.g,b:col.b,
                    size:.65+Math.random()*.2,
                    life:999,decay:0,grav:0,type:'mfinger'
                });
                if(!p)break;
                p.tx=wx+rx;p.ty=wy+ry;p.tz=wz+pt.z;
                p.localX=pt.x;p.localY=pt.y;p.localZ=pt.z;
                p.baseR=col.r;p.baseG=col.g;p.baseB=col.b;
                p.formDelay=Math.random()*.6;p.formTimer=0;p.formed=false;
                p.pulseOff=Math.random()*6.28;
                mfParticles.push(p);
            }

            // Inward spiral sparks
            for(let i=0;i<300;i++){
                const a1=Math.random()*Math.PI*2,a2=(Math.random()-.5)*Math.PI;
                const d=20+Math.random()*35;
                const sx=wx+Math.cos(a1)*Math.cos(a2)*d,sy=wy+10+Math.sin(a2)*d,sz=wz+Math.sin(a1)*Math.cos(a2)*d;
                const dx=wx-sx,dy=wy+10-sy,dz=wz-sz;const dl=Math.sqrt(dx*dx+dy*dy+dz*dz)+.01;
                const sp=1.3+Math.random();const tanx=-dz/dl,tanz=dx/dl;
                const c=randomRed();
                addP({x:sx,y:sy,z:sz,vx:dx/dl*sp+tanx*.6,vy:dy/dl*sp,vz:dz/dl*sp+tanz*.6,
                    r:c.r,g:c.g,b:c.b,size:.18+Math.random()*.15,life:1.2+Math.random()*1.2,decay:.012,type:'spark'});
            }

            for(let i=0;i<80;i++){const a=(i/80)*Math.PI*2;const sp=2+Math.random()*.5;const c=randomRed();
                addP({x:wx,y:wy,z:wz,vx:Math.cos(a)*sp,vy:(Math.random()-.5)*.3,vz:Math.sin(a)*sp,
                    r:c.r,g:c.g,b:c.b,size:.3,life:1.2+Math.random()*.4,decay:.015,grav:.003,type:'ring'});}

            screenShake(12);doFlash('spawn');
            mfCenter.set(wx,wy+10,wz);
        }

        function updateMiddleFingerPos(wx,wy,wz,angle){
            mfWorldPos.x+=(wx-mfWorldPos.x)*.12;
            mfWorldPos.y+=(wy-mfWorldPos.y)*.12;
            mfWorldPos.z+=(wz-mfWorldPos.z)*.12;
            mfAngle+=(angle-mfAngle)*.08;

            const ca=Math.cos(mfAngle),sa=Math.sin(mfAngle);
            for(const p of mfParticles){
                if(p.life<=0)continue;
                const rx=p.localX*ca-p.localY*sa;
                const ry=p.localX*sa+p.localY*ca;
                p.tx=mfWorldPos.x+rx;
                p.ty=mfWorldPos.y+ry;
                p.tz=mfWorldPos.z+p.localZ;
            }
            mfCenter.set(mfWorldPos.x,mfWorldPos.y+10,mfWorldPos.z);
        }

        function explodeMiddleFinger(){
            if(mfState==='exploding'||mfState==='none')return;
            mfState='exploding';mfTimer=0;
            const cx=mfCenter.x,cy=mfCenter.y,cz=mfCenter.z;
            screenShake(25);doFlash('explode');

            for(const p of mfParticles){
                if(p.life<=0)continue;
                p.type='imploding';
                const dx=cx-p.x,dy=cy-p.y,dz=cz-p.z;
                const dl=Math.sqrt(dx*dx+dy*dy+dz*dz)+.01;
                p.vx=dx/dl*3;p.vy=dy/dl*3;p.vz=dz/dl*3;
                p.grav=0;p.decay=0;p.maxLife=p.life=.22+Math.random()*.08;
                p.r=1;p.g=1;p.b=.9;
            }

            setTimeout(()=>{
                screenShake(35);doFlash('explode');
                for(let w=0;w<3;w++){
                    for(let i=0;i<200-w*50;i++){
                        const a1=Math.random()*Math.PI*2,a2=(Math.random()-.5)*Math.PI;
                        const sp=(2+w)+Math.random()*(4-w);const c=randomRed();
                        addP({x:cx+(Math.random()-.5)*3,y:cy+(Math.random()-.5)*3,z:cz+(Math.random()-.5)*3,
                            vx:Math.cos(a1)*Math.cos(a2)*sp,vy:Math.sin(a2)*sp+Math.random(),vz:Math.sin(a1)*Math.cos(a2)*sp,
                            r:c.r,g:c.g,b:c.b,size:.2+Math.random()*.35,life:2+Math.random()*2.5,decay:.007,grav:.012,type:'debris'});
                    }
                }
                for(let ring=0;ring<3;ring++){
                    for(let i=0;i<80-ring*20;i++){const a=(i/(80-ring*20))*Math.PI*2;const sp=3+ring*1.5;const c=randomRed();
                        addP({x:cx,y:cy+ring*2-2,z:cz,vx:Math.cos(a)*sp,vy:(Math.random()-.5)*.3,vz:Math.sin(a)*sp,
                            r:c.r,g:c.g,b:c.b,size:.4-ring*.08,life:1+Math.random()*.5,decay:.02,type:'ring'});}
                }
                for(let i=0;i<150;i++){const c=randomRed();
                    addP({x:cx+(Math.random()-.5)*5,y:cy-3+Math.random()*6,z:cz+(Math.random()-.5)*5,
                        vx:(Math.random()-.5)*.8,vy:2.5+Math.random()*4,vz:(Math.random()-.5)*.8,
                        r:c.r,g:c.g,b:c.b,size:.13+Math.random()*.15,life:1.5+Math.random()*2,decay:.009,grav:-.008,type:'fire'});}
                for(let i=0;i<100;i++){const a=Math.random()*Math.PI*2;const d=Math.random()*15;const c=randomRed();
                    addP({x:cx+Math.cos(a)*d,y:cy+5+Math.random()*15,z:cz+Math.sin(a)*d,
                        vx:(Math.random()-.5)*.3,vy:-.2-Math.random()*.4,vz:(Math.random()-.5)*.3,
                        r:c.r,g:c.g,b:c.b,size:.08+Math.random()*.06,life:3+Math.random()*3,decay:.004,grav:.006,type:'ember'});}
            },280);
        }

        // â”€â”€ DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let detected=false;let handVisible=false;
        let detectFrames=0,lostFrames=0;
        let currentLandmarks=null;

        const HAND_CONN=[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];

        function drawDebug(lm,isMF){
            const w=dbgCanvas.width,h=dbgCanvas.height;
            for(const[i,j]of HAND_CONN){
                const isMid=[9,10,11,12].includes(i)&&[9,10,11,12].includes(j);
                dbgCtx.beginPath();dbgCtx.moveTo(lm[i].x*w,lm[i].y*h);dbgCtx.lineTo(lm[j].x*w,lm[j].y*h);
                if(isMF&&isMid){dbgCtx.strokeStyle='#ff2020';dbgCtx.lineWidth=3;dbgCtx.shadowColor='#ff2020';dbgCtx.shadowBlur=6}
                else{dbgCtx.strokeStyle=isMF?'#44ff44':'#ff8800';dbgCtx.lineWidth=isMF?1.5:1.5;dbgCtx.shadowBlur=0}
                dbgCtx.stroke();dbgCtx.shadowBlur=0;
            }
            for(let i=0;i<lm.length;i++){
                const m=[9,10,11,12].includes(i);
                dbgCtx.beginPath();dbgCtx.arc(lm[i].x*w,lm[i].y*h,m&&isMF?4:2.5,0,Math.PI*2);
                dbgCtx.fillStyle=isMF?(m?'#ff2020':'#44ff44'):'#ff8800';dbgCtx.fill();
            }
            dbgCtx.font='bold 10px monospace';
            dbgCtx.fillStyle=isMF?'#ff2020':'#ff8800';
            dbgCtx.fillText(isMF?'ðŸ–• MIDDLE FINGER':'âœ‹ HAND TRACKED',6,14);
        }

        function checkMF(lm){
            const w=lm[0];
            const d3=(a,b)=>Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2+((a.z||0)-(b.z||0))**2);
            const palm={x:(lm[0].x+lm[5].x+lm[9].x+lm[13].x+lm[17].x)/5,
                y:(lm[0].y+lm[5].y+lm[9].y+lm[13].y+lm[17].y)/5,
                z:((lm[0].z||0)+(lm[5].z||0)+(lm[9].z||0)+(lm[13].z||0)+(lm[17].z||0))/5};
            function ext(t,d,p,m){return d3(t,w)>d3(m,w)*1.1&&d3(t,palm)>d3(m,palm)*1.15&&d3(t,m)>d3(p,m)*1.4}
            function curl(t,d,p,m){return d3(t,w)<d3(m,w)*1.15||d3(t,palm)<d3(m,palm)*.95||d3(t,m)<d3(p,m)*1.2}
            const mE=ext(lm[12],lm[11],lm[10],lm[9]);
            const iC=curl(lm[8],lm[7],lm[6],lm[5]);
            const rC=curl(lm[16],lm[15],lm[14],lm[13]);
            const pC=curl(lm[20],lm[19],lm[18],lm[17]);
            const mL=d3(lm[12],lm[9]);
            const dom=mL>d3(lm[8],lm[5])*1.2&&mL>d3(lm[16],lm[13])*1.2&&mL>d3(lm[20],lm[17])*1.2;
            return mE&&iC&&rC&&pC&&dom;
        }

        const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${f}`});
        hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:.6,minTrackingConfidence:.5});
        hands.onResults(res=>{
            dbgCtx.clearRect(0,0,dbgCanvas.width,dbgCanvas.height);
            dbgCtx.globalAlpha=.2;dbgCtx.drawImage(res.image,0,0,dbgCanvas.width,dbgCanvas.height);dbgCtx.globalAlpha=1;

            let rawMF=false;
            handVisible=false;
            currentLandmarks=null;

            if(res.multiHandLandmarks&&res.multiHandLandmarks.length>0){
                for(const lm of res.multiHandLandmarks){
                    handVisible=true;
                    currentLandmarks=lm;
                    const isMF=checkMF(lm);
                    drawDebug(lm,isMF);
                    if(isMF)rawMF=true;
                }
            }

            if(rawMF){detectFrames++;lostFrames=0}else{lostFrames++;detectFrames=0}
            if(detectFrames>=3)middleFingerDetected=true;
            if(lostFrames>=8)middleFingerDetected=false;

            if(middleFingerDetected){
                statusEl.textContent='ðŸ–• MIDDLE FINGER DETECTED';statusEl.className='active';
            }else if(handVisible){
                statusEl.textContent='âœ‹ Hand tracked â€” flip the bird!';statusEl.className='hand';
            }else{
                statusEl.textContent='Show your hand âœ‹';statusEl.className='';
            }
        });

        async function startCam(){
            try{const s=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480,facingMode:'user'}});
                video.srcObject=s;new Camera(video,{onFrame:async()=>await hands.send({image:video}),width:640,height:480}).start();
                loadingScreen.style.display='none';
            }catch(e){loadingScreen.innerHTML='<p style="color:#f55">Camera denied</p>'}
        }

        // â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let prev=performance.now();let globalTime=0;
        let wasMF=false;
        let camTarget=new THREE.Vector3(0,0,0);
        let camSway=0;

        function loop(){
            requestAnimationFrame(loop);
            const now=performance.now();const dt=Math.min((now-prev)/1000,.05);prev=now;
            globalTime+=dt;camSway+=dt;

            // â”€â”€ Real-time hand tracking particles â”€â”€
            if(handVisible&&currentLandmarks){
                updateHandTracking(currentLandmarks);
                fingerLight.intensity+=(2.5-fingerLight.intensity)*dt*5;
                fingerLight2.intensity+=(middleFingerDetected?4:1.5-fingerLight2.intensity)*dt*5;
            }else{
                fingerLight.intensity+=(0-fingerLight.intensity)*dt*3;
                fingerLight2.intensity+=(0-fingerLight2.intensity)*dt*3;
                smoothLandmarks=null;
                prevLandmarks=null;
            }

            // â”€â”€ Middle finger gesture â”€â”€
            if(middleFingerDetected&&currentLandmarks){
                const lm=smoothLandmarks||currentLandmarks;
                const palmW=lmToWorld({
                    x:(lm[0].x+lm[5].x+lm[9].x+lm[13].x+lm[17].x)/5,
                    y:(lm[0].y+lm[5].y+lm[9].y+lm[13].y+lm[17].y)/5,
                    z:((lm[0].z||0)+(lm[5].z||0)+(lm[9].z||0)+(lm[13].z||0)+(lm[17].z||0))/5
                });
                const dx=lm[9].x-lm[0].x,dy=lm[9].y-lm[0].y;
                const angle=Math.atan2(-(1-lm[9].x-(1-lm[0].x)),-(lm[9].y-lm[0].y));

                if(mfState==='none'||mfState==='exploding'){
                    spawnMiddleFinger(palmW.x,palmW.y-5,palmW.z,angle);
                }else{
                    updateMiddleFingerPos(palmW.x,palmW.y-5,palmW.z,angle);
                }
                wasMF=true;
            }else{
                if(wasMF&&(mfState==='forming'||mfState==='alive')){
                    explodeMiddleFinger();
                }
                wasMF=false;
            }

            // â”€â”€ Middle finger group update â”€â”€
            if(mfState==='forming'){
                mfTimer+=dt;
                let allDone=true;
                for(const p of mfParticles){
                    if(p.life<=0)continue;
                    p.formTimer=(p.formTimer||0)+dt;
                    if(p.formTimer<(p.formDelay||0)){allDone=false;continue}
                    const t=Math.min(1,(p.formTimer-p.formDelay)*2);
                    const ease=t===0?0:t===1?1:Math.pow(2,-10*t)*Math.sin((t*10-.75)*2.094)+1;
                    const startX=p.tx+(p.x-p.tx)/(ease||1);
                    p.x+=(p.tx-p.x)*ease*.15;
                    p.y+=(p.ty-p.y)*ease*.15;
                    p.z+=(p.tz-p.z)*ease*.15;
                    p.formed=Math.abs(p.x-p.tx)<.3&&Math.abs(p.y-p.ty)<.3;
                    p.size=(.65+Math.random()*.05)*Math.min(1,ease*1.3);
                    if(!p.formed)allDone=false;
                    if(Math.random()<.03&&P.length<MAX-100){const c=randomRed();
                        addP({x:p.x,y:p.y,z:p.z,vx:(Math.random()-.5)*.3,vy:(Math.random()-.5)*.3,vz:(Math.random()-.5)*.3,
                            r:c.r,g:c.g,b:c.b,size:.1,life:.3+Math.random()*.3,decay:.035,type:'trail'});}
                }
                if(allDone||mfTimer>2){mfState='alive';screenShake(5);doFlash('spawn');
                    for(let i=0;i<50;i++){const a=(i/50)*Math.PI*2;const c=randomRed();
                        addP({x:mfCenter.x,y:mfCenter.y,z:mfCenter.z,vx:Math.cos(a)*1.5,vy:(Math.random()-.5)*.4,vz:Math.sin(a)*1.5,
                            r:c.r,g:c.g,b:c.b,size:.25,life:.5+Math.random()*.3,decay:.03,type:'ring'});}}
            }

            if(mfState==='alive'){
                mfTimer+=dt;
                for(const p of mfParticles){
                    if(p.life<=0)continue;
                    p.shimmer+=dt*3;
                    const pulse=Math.sin(mfTimer*3+p.pulseOff)*.12;
                    p.r=Math.min(1,p.baseR+pulse*.3);
                    p.g=Math.min(1,p.baseG+pulse*.5);
                    p.b=Math.min(1,p.baseB+pulse*.2);
                    p.x+=(p.tx-p.x)*.15+Math.sin(p.shimmer*.5)*.05;
                    p.y+=(p.ty-p.y)*.15+Math.sin(p.shimmer*.35)*.05+Math.sin(mfTimer*.5)*.01;
                    p.z+=(p.tz-p.z)*.15+Math.sin(p.shimmer*.6)*.05;
                    p.size=.65+Math.sin(p.shimmer+p.pulseOff)*.08;
                }
                // Embers
                if(Math.random()<.3&&P.length<MAX-20){const c=randomRed();
                    addP({x:mfCenter.x+(Math.random()-.5)*8,y:mfCenter.y-8+Math.random()*18,z:mfCenter.z+(Math.random()-.5)*4,
                        vx:(Math.random()-.5)*.15,vy:.3+Math.random()*.4,vz:(Math.random()-.5)*.15,
                        r:c.r,g:c.g,b:c.b,size:.06+Math.random()*.05,life:1.5+Math.random()*2,decay:.007,grav:-.002,type:'ember'});}
            }

            if(mfState==='exploding'){
                mfTimer+=dt;
                let any=false;
                for(const p of mfParticles){if(p.life>0){any=true;break}}
                if(!any&&mfTimer>4)mfState='none';
            }

            // â”€â”€ Camera â”€â”€
            if(handVisible&&smoothLandmarks){
                const pc=lmToWorld({
                    x:(smoothLandmarks[0].x+smoothLandmarks[9].x)/2,
                    y:(smoothLandmarks[0].y+smoothLandmarks[9].y)/2,
                    z:((smoothLandmarks[0].z||0)+(smoothLandmarks[9].z||0))/2
                });
                camTarget.lerp(new THREE.Vector3(pc.x,pc.y,pc.z),dt*2);
            }else{
                camTarget.lerp(new THREE.Vector3(0,0,0),dt*.5);
            }
            const sway=Math.sin(camSway*.2)*1.5;
            const sy=Math.sin(camSway*.15)*.8;
            camera.position.set(camTarget.x+sway,camTarget.y+sy+3,42);

            shakeAmount*=.88;if(shakeAmount<.01)shakeAmount=0;
            const st=camTarget.clone();
            st.x+=(Math.random()-.5)*shakeAmount;st.y+=(Math.random()-.5)*shakeAmount;
            camera.lookAt(st);

            // Bloom strength
            const hasMF=mfState==='alive'||mfState==='forming';
            compMat.uniforms.bloomStrength.value+=((hasMF?2.5:handVisible?1.5:.5)-compMat.uniforms.bloomStrength.value)*dt*3;

            // â”€â”€ Update all particles â”€â”€
            let alive=0;
            for(let i=P.length-1;i>=0;i--){
                const p=P[i];
                if(p.type==='hand'){
                    p.life-=p.decay*dt*60;
                }else if(p.type==='mfinger'){
                    // handled above
                }else if(p.type==='imploding'){
                    p.x+=p.vx*dt*60;p.y+=p.vy*dt*60;p.z+=p.vz*dt*60;
                    p.life-=dt;p.size=.5*(Math.max(0,p.life)/p.maxLife);
                }else{
                    p.x+=p.vx;p.y+=p.vy;p.z+=p.vz;p.vy-=p.grav;
                    p.vx*=.995;p.vz*=.995;p.life-=p.decay;
                    p.rotX+=p.spin;p.rotY+=p.spin*.7;
                }
                if(p.life<=0){P.splice(i,1);continue}

                const f=p.type==='mfinger'||p.type==='hand'?1:Math.max(0,p.life/p.maxLife);
                const s=Math.max(.01,p.size*(p.type==='mfinger'||p.type==='hand'?1:(.1+f*.9)));
                dum.position.set(p.x,p.y,p.z);
                dum.scale.setScalar(s);
                dum.rotation.set(p.rotX||0,p.rotY||0,0);
                dum.updateMatrix();
                imesh.setMatrixAt(alive,dum.matrix);

                // ACTUALLY SET THE COLOR
                const fr=p.type==='mfinger'||p.type==='hand'?1:f;
                tc.setRGB(
                    Math.min(1,Math.max(0,p.r*fr)),
                    Math.min(1,Math.max(0,p.g*fr)),
                    Math.min(1,Math.max(0,p.b*fr))
                );
                imesh.setColorAt(alive,tc);
                alive++;
            }

            if(alive<imesh.count){
                dum.position.set(0,-999,0);dum.scale.setScalar(0);dum.updateMatrix();
                for(let i=alive;i<imesh.count;i++){imesh.setMatrixAt(i,dum.matrix);imesh.setColorAt(i,tc)}
            }
            imesh.count=alive;
            imesh.instanceMatrix.needsUpdate=true;
            if(imesh.instanceColor)imesh.instanceColor.needsUpdate=true;

            renderBloom();
        }

        loop();startCam();
    })();
    </script>
</body>
</html>
