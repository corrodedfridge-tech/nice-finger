<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Middle Finger Particles</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #111; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #video {
            position: fixed; bottom: 15px; right: 15px; width: 180px; height: 135px;
            border: 2px solid #333; border-radius: 6px; z-index: 20;
            transform: scaleX(-1); object-fit: cover;
        }
        #status {
            position: fixed; top: 15px; left: 50%; transform: translateX(-50%);
            color: #ccc; font-size: 15px; z-index: 30; text-align: center;
            background: rgba(0,0,0,0.6); padding: 6px 14px; border-radius: 6px;
        }
        #status.active { color: #f55; }
        .loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #ccc; font-size: 20px; z-index: 100; text-align: center;
        }
        .spinner {
            border: 3px solid #333; border-top: 3px solid #ccc; border-radius: 50%;
            width: 36px; height: 36px; animation: s 1s linear infinite; margin: 12px auto;
        }
        @keyframes s { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loadingScreen" class="loading"><div class="spinner"></div><p>Loading...</p></div>
    <video id="video" autoplay playsinline></video>
    <div id="status">Show your middle finger ðŸ–•</div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    (function () {
        const video = document.getElementById('video');
        const statusEl = document.getElementById('status');
        const loadingScreen = document.getElementById('loadingScreen');

        // â”€â”€ THREE SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111118);

        const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 500);
        camera.position.set(0, 15, 55);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(1);
        document.body.prepend(renderer.domElement);

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        // Simple directional light + ambient
        scene.add(new THREE.AmbientLight(0x888888));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(5, 20, 10);
        scene.add(dirLight);

        // Grid
        const grid = new THREE.GridHelper(160, 30, 0x333333, 0x222222);
        grid.position.y = -18;
        scene.add(grid);

        // â”€â”€ INSTANCED MESH (single draw call, same geometry) â”€â”€â”€â”€â”€
        const SPHERE = new THREE.IcosahedronGeometry(0.35, 0);
        const MAT = new THREE.MeshLambertMaterial({ color: 0xdddddd });
        const MAX = 15000;
        const mesh = new THREE.InstancedMesh(SPHERE, MAT, MAX);
        mesh.count = 0;
        scene.add(mesh);

        const dummy = new THREE.Object3D();
        const tmpColor = new THREE.Color();

        // Particle data
        const P = []; // {x,y,z,vx,vy,vz,life,decay,grav,r,g,b}

        function addP(x, y, z, vx, vy, vz, r, g, b, life, decay, grav) {
            if (P.length >= MAX) return;
            P.push({ x, y, z, vx, vy, vz, r, g, b, life, maxLife: life, decay, grav });
        }

        // â”€â”€ MIDDLE FINGER POINT CLOUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function fingerPoints() {
            const pts = [];

            // Middle finger shaft
            for (let y = 0; y < 15; y += 0.9) {
                const n = 8;
                for (let i = 0; i < n; i++) {
                    const a = (i / n) * Math.PI * 2;
                    const r = 1.6;
                    pts.push({ x: Math.cos(a) * r, y: y + 6, z: Math.sin(a) * r });
                }
            }

            // Fingertip hemisphere
            for (let p = 0; p < Math.PI / 2; p += 0.4) {
                const n = Math.max(4, Math.floor(8 * Math.cos(p)));
                for (let i = 0; i < n; i++) {
                    const a = (i / n) * Math.PI * 2;
                    const r = 1.6 * Math.cos(p);
                    pts.push({ x: Math.cos(a) * r, y: 21 + Math.sin(p) * 1.6, z: Math.sin(a) * r });
                }
            }

            // Fist block
            for (let y = 0; y < 5; y += 1.0) {
                for (let x = -4.5; x <= 4.5; x += 1.0) {
                    for (let z = -1.8; z <= 1.8; z += 1.0) {
                        pts.push({ x, y: y * 0.9, z });
                    }
                }
            }

            // Curled finger bumps
            for (const fx of [-3.2, -1.2, 1.2, 3.2]) {
                for (let a = 0; a < Math.PI; a += 0.5) {
                    const r = 1.0;
                    pts.push({ x: fx + Math.cos(a + Math.PI) * r, y: 5 + Math.sin(a + Math.PI) * r, z: 0 });
                    pts.push({ x: fx + Math.cos(a + Math.PI) * r, y: 5 + Math.sin(a + Math.PI) * r, z: 1 });
                    pts.push({ x: fx + Math.cos(a + Math.PI) * r, y: 5 + Math.sin(a + Math.PI) * r, z: -1 });
                }
            }

            // Thumb
            for (let t = 0; t < 7; t++) {
                const ty = 1 + t * 0.7;
                const tx = 5 + Math.sin(t * 0.3) * 1.2;
                for (let i = 0; i < 5; i++) {
                    const a = (i / 5) * Math.PI * 2;
                    pts.push({ x: tx + Math.cos(a) * 0.9, y: ty, z: Math.sin(a) * 0.9 });
                }
            }

            return pts;
        }

        const FPTS = fingerPoints();

        function spawnFinger(wx, wy, wz) {
            // Finger shape
            for (const pt of FPTS) {
                addP(
                    wx + pt.x, wy + pt.y, wz + pt.z,
                    (Math.random() - 0.5) * 0.03,
                    (Math.random() - 0.5) * 0.03,
                    (Math.random() - 0.5) * 0.03,
                    0.85, 0.75, 0.65,
                    5 + Math.random() * 2, 0.008, 0
                );
            }

            // Burst
            for (let i = 0; i < 100; i++) {
                const a1 = Math.random() * Math.PI * 2;
                const a2 = (Math.random() - 0.5) * Math.PI;
                const sp = 0.6 + Math.random() * 1.0;
                addP(
                    wx, wy + 10, wz,
                    Math.cos(a1) * Math.cos(a2) * sp,
                    Math.sin(a2) * sp * 0.5 + 0.3,
                    Math.sin(a1) * Math.cos(a2) * sp,
                    0.9, 0.5, 0.3,
                    1.5 + Math.random() * 1.5, 0.015, -0.005
                );
            }

            // Ring
            for (let i = 0; i < 50; i++) {
                const a = (i / 50) * Math.PI * 2;
                addP(
                    wx, wy + 4, wz,
                    Math.cos(a) * 1.2, 0, Math.sin(a) * 1.2,
                    0.7, 0.7, 0.7,
                    1.2 + Math.random() * 0.8, 0.018, 0
                );
            }

            return new THREE.Vector3(wx, wy + 12, wz);
        }

        // â”€â”€ CAMERA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let camTarget = new THREE.Vector3(0, 8, 0);
        let camGoalPos = new THREE.Vector3(0, 15, 55);
        let camAngle = 0;
        let lastDetect = 0;

        function aimCamera(target) {
            camAngle = Math.atan2(camera.position.x - target.x, camera.position.z - target.z);
            camGoalPos.set(
                target.x + Math.sin(camAngle) * 40,
                target.y + 12,
                target.z + Math.cos(camAngle) * 40
            );
            camTarget.copy(target);
            lastDetect = performance.now();
        }

        // â”€â”€ HAND DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let detected = false;
        let fingerNorm = { x: 0.5, y: 0.5 };
        let spawnCD = 0;

        function checkMiddleFinger(lm) {
            const w = lm[0];
            const d = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
            const ext = (t, m) => d(t, w) > d(m, w) * 1.15;
            const cur = (t, m) => d(t, w) < d(m, w) * 1.1;
            return ext(lm[12], lm[9]) && cur(lm[8], lm[5]) && cur(lm[16], lm[13]) && cur(lm[20], lm[17]);
        }

        const hands = new Hands({
            locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${f}`
        });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.5 });
        hands.onResults(res => {
            let found = false;
            if (res.multiHandLandmarks) {
                for (const lm of res.multiHandLandmarks) {
                    if (checkMiddleFinger(lm)) {
                        found = true;
                        fingerNorm = { x: 1 - lm[12].x, y: lm[12].y };
                    }
                }
            }
            detected = found;
            statusEl.textContent = found ? 'ðŸ–• DETECTED!' : 'Show your middle finger ðŸ–•';
            statusEl.className = found ? 'active' : '';
        });

        async function startCam() {
            try {
                const s = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, facingMode: 'user' } });
                video.srcObject = s;
                new Camera(video, {
                    onFrame: async () => await hands.send({ image: video }),
                    width: 640, height: 480
                }).start();
                loadingScreen.style.display = 'none';
            } catch (e) {
                loadingScreen.innerHTML = '<p style="color:#f55">Camera access denied â€” allow and reload</p>';
            }
        }

        // â”€â”€ LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let prev = performance.now();

        function loop() {
            requestAnimationFrame(loop);
            const now = performance.now();
            const dt = Math.min((now - prev) / 1000, 0.05);
            prev = now;

            // Spawn
            if (detected) {
                spawnCD -= dt;
                if (spawnCD <= 0) {
                    const wx = (fingerNorm.x - 0.5) * 55;
                    const wy = (0.5 - fingerNorm.y) * 35 + 5;
                    const wz = (Math.random() - 0.5) * 25;
                    const t = spawnFinger(wx, wy, wz);
                    aimCamera(t);
                    spawnCD = 1.5;
                }
            }

            // Camera
            const idle = now - lastDetect > 5000;
            if (idle) {
                camAngle += dt * 0.15;
                camGoalPos.set(Math.sin(camAngle) * 55, 18, Math.cos(camAngle) * 55);
                camTarget.lerp(new THREE.Vector3(0, 6, 0), dt * 0.4);
            } else {
                camAngle += dt * 0.25;
                camGoalPos.set(
                    camTarget.x + Math.sin(camAngle) * 40,
                    camTarget.y + 12,
                    camTarget.z + Math.cos(camAngle) * 40
                );
            }
            camera.position.lerp(camGoalPos, dt * 2.2);
            camera.lookAt(camTarget);

            // Update particles
            let alive = 0;
            for (let i = P.length - 1; i >= 0; i--) {
                const p = P[i];
                p.x += p.vx; p.y += p.vy; p.z += p.vz;
                p.vy += p.grav;
                p.vx *= 0.999; p.vz *= 0.999;
                p.life -= p.decay;
                if (p.life <= 0) { P.splice(i, 1); continue; }

                const f = p.life / p.maxLife;
                dummy.position.set(p.x, p.y, p.z);
                dummy.scale.setScalar(0.6 + f * 0.4);
                dummy.updateMatrix();
                mesh.setMatrixAt(alive, dummy.matrix);
                tmpColor.setRGB(p.r * f, p.g * f, p.b * f);
                mesh.setColorAt(alive, tmpColor);
                alive++;
            }

            // Hide unused instances far away
            if (alive < mesh.count) {
                dummy.position.set(0, -500, 0);
                dummy.scale.setScalar(0);
                dummy.updateMatrix();
                for (let i = alive; i < mesh.count; i++) {
                    mesh.setMatrixAt(i, dummy.matrix);
                }
            }

            mesh.count = alive;
            mesh.instanceMatrix.needsUpdate = true;
            if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;

            renderer.render(scene, camera);
        }

        loop();
        startCam();
    })();
    </script>
</body>
</html>
