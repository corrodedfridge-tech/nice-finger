<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ–• EPIC Middle Finger</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;font-family:'Segoe UI',Arial,sans-serif}
        #video{position:fixed;bottom:15px;right:15px;width:220px;height:165px;border:1px solid #222;border-radius:8px;z-index:20;transform:scaleX(-1);object-fit:cover;opacity:.9}
        #debugCanvas{position:fixed;bottom:15px;left:15px;width:220px;height:165px;border:1px solid #333;border-radius:8px;z-index:20;background:#000}
        #status{position:fixed;top:15px;left:50%;transform:translateX(-50%);color:#555;font-size:13px;z-index:30;text-align:center;background:rgba(0,0,0,.85);padding:8px 18px;border-radius:20px;border:1px solid #222;letter-spacing:.5px;transition:all .3s}
        #status.active{color:#ff2020;border-color:#ff2020;box-shadow:0 0 25px rgba(255,30,30,.4)}
        #flash{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;opacity:0;transition:opacity .15s}
        #flash.spawn{opacity:1;background:radial-gradient(circle,rgba(255,60,20,.3),transparent 70%);transition:opacity .03s}
        #flash.explode{opacity:1;background:radial-gradient(circle,rgba(255,255,255,.5),rgba(255,40,20,.3) 40%,transparent 70%);transition:opacity .03s}
        #vignette{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:4;background:radial-gradient(ellipse at center,transparent 50%,rgba(0,0,0,.7))}
        .loading{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#666;font-size:16px;z-index:100;text-align:center}
        .spinner{border:2px solid #1a1a1a;border-top:2px solid #ff2020;border-radius:50%;width:32px;height:32px;animation:s .8s linear infinite;margin:12px auto}
        @keyframes s{to{transform:rotate(360deg)}}
    </style>
</head>
<body>
    <div id="loadingScreen" class="loading"><div class="spinner"></div><p>Loading hand tracking...</p></div>
    <div id="vignette"></div>
    <div id="flash"></div>
    <video id="video" autoplay playsinline></video>
    <canvas id="debugCanvas"></canvas>
    <div id="status">Show your middle finger ðŸ–•</div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    (function(){
        const video=document.getElementById('video');
        const statusEl=document.getElementById('status');
        const loadingScreen=document.getElementById('loadingScreen');
        const flashEl=document.getElementById('flash');
        const dbgCanvas=document.getElementById('debugCanvas');
        const dbgCtx=dbgCanvas.getContext('2d');
        dbgCanvas.width=320;dbgCanvas.height=240;

        let shakeAmount=0;
        function screenShake(a){shakeAmount=Math.max(shakeAmount,a)}
        function doFlash(type){flashEl.className='';void flashEl.offsetWidth;flashEl.classList.add(type);setTimeout(()=>flashEl.className='',200)}

        // â”€â”€ THREE SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const scene=new THREE.Scene();
        scene.background=new THREE.Color(0x000000);
        const camera=new THREE.PerspectiveCamera(50,innerWidth/innerHeight,.1,800);
        camera.position.set(0,14,40);
        const renderer=new THREE.WebGLRenderer({antialias:false});
        renderer.setSize(innerWidth,innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio,2));
        renderer.shadowMap.enabled=false;
        document.body.prepend(renderer.domElement);
        window.addEventListener('resize',()=>{
            camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();
            renderer.setSize(innerWidth,innerHeight);
            rtMain.setSize(innerWidth,innerHeight);
            const w4=Math.floor(innerWidth/4),h4=Math.floor(innerHeight/4);
            rtA.setSize(w4,h4);rtB.setSize(w4,h4);
        });

        scene.add(new THREE.AmbientLight(0xffffff,.5));
        const dL=new THREE.DirectionalLight(0xffddcc,.3);dL.position.set(10,20,15);scene.add(dL);

        // â”€â”€ BLOOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const ortho=new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        const rtp={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};
        let rtA=new THREE.WebGLRenderTarget(Math.floor(innerWidth/4),Math.floor(innerHeight/4),rtp);
        let rtB=new THREE.WebGLRenderTarget(Math.floor(innerWidth/4),Math.floor(innerHeight/4),rtp);
        let rtMain=new THREE.WebGLRenderTarget(innerWidth,innerHeight,rtp);
        const blurMat=new THREE.ShaderMaterial({
            uniforms:{tDiffuse:{value:null},direction:{value:new THREE.Vector2(1,0)},resolution:{value:new THREE.Vector2(rtA.width,rtA.height)}},
            vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.);}`,
            fragmentShader:`uniform sampler2D tDiffuse;uniform vec2 direction;uniform vec2 resolution;varying vec2 vUv;
            void main(){vec2 o=direction/resolution;vec4 c=vec4(0.);
            c+=texture2D(tDiffuse,vUv-4.*o)*.02;c+=texture2D(tDiffuse,vUv-3.*o)*.06;c+=texture2D(tDiffuse,vUv-2.*o)*.12;
            c+=texture2D(tDiffuse,vUv-1.*o)*.2;c+=texture2D(tDiffuse,vUv)*.2;c+=texture2D(tDiffuse,vUv+1.*o)*.2;
            c+=texture2D(tDiffuse,vUv+2.*o)*.12;c+=texture2D(tDiffuse,vUv+3.*o)*.06;c+=texture2D(tDiffuse,vUv+4.*o)*.02;gl_FragColor=c;}`
        });
        const compMat=new THREE.ShaderMaterial({
            uniforms:{tScene:{value:null},tBloom:{value:null},bloomStrength:{value:1.5}},
            vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.);}`,
            fragmentShader:`uniform sampler2D tScene;uniform sampler2D tBloom;uniform float bloomStrength;varying vec2 vUv;
            void main(){gl_FragColor=texture2D(tScene,vUv)+texture2D(tBloom,vUv)*bloomStrength;gl_FragColor.a=1.;}`
        });
        const fsGeo=new THREE.PlaneGeometry(2,2);
        const blurQ=new THREE.Mesh(fsGeo,blurMat);const blurSc=new THREE.Scene();blurSc.add(blurQ);
        const compQ=new THREE.Mesh(fsGeo,compMat);const compSc=new THREE.Scene();compSc.add(compQ);
        function renderBloom(){
            renderer.setRenderTarget(rtMain);renderer.render(scene,camera);
            blurMat.uniforms.tDiffuse.value=rtMain.texture;blurMat.uniforms.direction.value.set(1,0);
            blurMat.uniforms.resolution.value.set(rtA.width,rtA.height);
            renderer.setRenderTarget(rtA);renderer.render(blurSc,ortho);
            blurMat.uniforms.tDiffuse.value=rtA.texture;blurMat.uniforms.direction.value.set(0,1);
            renderer.setRenderTarget(rtB);renderer.render(blurSc,ortho);
            blurMat.uniforms.tDiffuse.value=rtB.texture;blurMat.uniforms.direction.value.set(1,0);
            renderer.setRenderTarget(rtA);renderer.render(blurSc,ortho);
            blurMat.uniforms.tDiffuse.value=rtA.texture;blurMat.uniforms.direction.value.set(0,1);
            renderer.setRenderTarget(rtB);renderer.render(blurSc,ortho);
            compMat.uniforms.tScene.value=rtMain.texture;compMat.uniforms.tBloom.value=rtB.texture;
            renderer.setRenderTarget(null);renderer.render(compSc,ortho);
        }

        // â”€â”€ INSTANCED MESH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const GEO=new THREE.BoxGeometry(.38,.38,.38);
        const MAT=new THREE.MeshBasicMaterial({color:0xffffff});
        const MAX=40000;
        const imesh=new THREE.InstancedMesh(GEO,MAT,MAX);
        imesh.count=0;scene.add(imesh);
        const dum=new THREE.Object3D();const tc=new THREE.Color();

        const fingerLight=new THREE.PointLight(0xff2200,0,100);scene.add(fingerLight);
        let fingerLightTarget=0;

        // â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const P=[];
        function addP(x,y,z,vx,vy,vz,r,g,b,size,life,decay,grav,type){
            if(P.length>=MAX)return;
            P.push({x,y,z,vx,vy,vz,r,g,b,size,life,maxLife:life,decay,grav,type:type||'fx',
                spin:(Math.random()-.5)*.15,rotX:Math.random()*6.28,rotY:Math.random()*6.28,
                baseR:r,baseG:g,baseB:b,shimmer:Math.random()*6.28,pulseOffset:Math.random()*6.28});
        }

        // Color helpers
        function fingerColor(h){
            const p=Math.random();
            if(p<.35)return{r:.85+Math.random()*.15,g:.03+h*.15+Math.random()*.04,b:.01+Math.random()*.03};
            if(p<.6)return{r:.95+Math.random()*.05,g:.15+h*.3+Math.random()*.08,b:.01+Math.random()*.04};
            if(p<.82)return{r:.9+Math.random()*.1,g:.3+h*.35+Math.random()*.1,b:.02+Math.random()*.06};
            return{r:1,g:.7+Math.random()*.3,b:.4+Math.random()*.4};
        }
        function fxColor(){
            const t=Math.random();
            if(t<.35)return{r:1,g:.08+Math.random()*.12,b:.01+Math.random()*.03};
            if(t<.6)return{r:1,g:.25+Math.random()*.2,b:.02+Math.random()*.05};
            if(t<.85)return{r:1,g:.45+Math.random()*.25,b:.05+Math.random()*.1};
            return{r:1,g:.85+Math.random()*.15,b:.5+Math.random()*.4};
        }

        // â”€â”€ FINGER MODEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function buildFinger(){
            const pts=[];
            function cyl(cx,cy,cz,rad,h,step,seg){
                for(let y=0;y<h;y+=step){const t=y/h;const r=rad*(1-t*.12);
                    for(let i=0;i<seg;i++){const a=(i/seg)*Math.PI*2;pts.push({x:cx+Math.cos(a)*r,y:cy+y,z:cz+Math.sin(a)*r})}
                    if(y%(step*2)<step)for(let i=0;i<Math.max(2,seg-3);i++){const a=(i/(seg-3))*Math.PI*2;pts.push({x:cx+Math.cos(a)*r*.45,y:cy+y,z:cz+Math.sin(a)*r*.45})}
                }
            }
            function hemi(cx,cy,cz,rad,seg){
                for(let p=0;p<Math.PI/2;p+=.22){const r=rad*Math.cos(p);const n=Math.max(3,Math.round(seg*Math.cos(p)));
                    for(let i=0;i<n;i++){const a=(i/n)*Math.PI*2;pts.push({x:cx+Math.cos(a)*r,y:cy+Math.sin(p)*rad,z:cz+Math.sin(a)*r})}}
                pts.push({x:cx,y:cy+rad,z:cz});
            }
            function box(cx,cy,cz,w,h,d,step){
                for(let y=0;y<=h;y+=step){
                    for(let x=-w/2;x<=w/2;x+=step){pts.push({x:cx+x,y:cy+y,z:cz+d/2});pts.push({x:cx+x,y:cy+y,z:cz-d/2})}
                    for(let z=-d/2;z<=d/2;z+=step){pts.push({x:cx-w/2,y:cy+y,z:cz+z});pts.push({x:cx+w/2,y:cy+y,z:cz+z})}
                }
                for(let x=-w/2;x<=w/2;x+=step)for(let z=-d/2;z<=d/2;z+=step){pts.push({x:cx+x,y:cy,z:cz+z});pts.push({x:cx+x,y:cy+h,z:cz+z})}
            }
            cyl(0,5.5,0,1.15,14.5,.45,11);
            hemi(0,20,0,1.15,11);
            box(0,0,0,8.5,5.5,3.5,.65);
            for(let y=.5;y<5;y+=1.2)for(let x=-3;x<=3;x+=1.4)pts.push({x,y,z:0});
            for(const fx of[-3,-1,1,3])
                for(let t=0;t<=1;t+=.06){const a=t*Math.PI*.75;const cy=5.5+Math.sin(a)*1.5;const cz=Math.cos(a)*1.5-.5;
                    for(let i=0;i<5;i++){const ang=(i/5)*Math.PI*2;pts.push({x:fx+Math.cos(ang)*.5,y:cy+Math.sin(ang)*.55,z:cz})}}
            for(let t=0;t<=1;t+=.04){const tx=4.75+Math.sin(t*1.2)*1.5;const ty=.8+t*3.8;const tz=1.75*(1-t*.6)+.5;
                for(let i=0;i<5;i++){const a=(i/5)*Math.PI*2;pts.push({x:tx+Math.cos(a)*.6,y:ty,z:tz+Math.sin(a)*.6})}}
            hemi(4.75+Math.sin(1.2)*1.5,4.6,1.75*.4+.5,.6,4);
            for(let y=-3;y<0;y+=.55){const s=1+y*.04;
                for(let x=-4.25*s;x<=4.25*s;x+=.75){pts.push({x,y,z:1.75*s});pts.push({x,y,z:-1.75*s})}}
            return pts;
        }
        const FPTS=buildFinger();

        // â”€â”€ ACTIVE HAND GROUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Instead of spawning static, we keep one group alive and move it to follow the hand
        let activeGroup=null;
        let groups=[];
        let gid=0;

        // Hand tracking data: position + rotation
        let handData={
            detected:false,
            // Normalized screen coords of middle finger base (MCP joint 9)
            nx:0.5, ny:0.5,
            // Hand rotation (angle of wrist-to-middle-finger axis)
            angle:0,
            // Hand "depth" based on hand size
            depth:1,
            // Palm center
            palmNx:0.5, palmNy:0.5
        };

        function normToWorld(nx,ny,depth){
            // Convert normalized screen coords to 3D world position
            // facing front on the Z plane
            return new THREE.Vector3(
                (nx-.5)*60*depth,
                (.5-ny)*45*depth,
                0
            );
        }

        function spawnFinger(wx,wy,wz,angle){
            const id=gid++;const gp=[];
            const cosA=Math.cos(angle),sinA=Math.sin(angle);

            for(const pt of FPTS){
                if(P.length>=MAX-2000)break;
                const h=(pt.y+3)/25;
                const col=fingerColor(h);
                // Rotate point around Y axis... actually rotate in screen plane (around Z)
                const rx=pt.x*cosA-pt.y*sinA;
                const ry=pt.x*sinA+pt.y*cosA;

                const p={
                    x:0,y:0,z:0,
                    tx:wx+rx, ty:wy+ry, tz:wz+pt.z,
                    vx:0,vy:0,vz:0,
                    r:col.r,g:col.g,b:col.b,baseR:col.r,baseG:col.g,baseB:col.b,
                    size:.7+Math.random()*.2,life:999,maxLife:999,decay:0,grav:0,
                    type:'finger',groupId:id,
                    formDelay:Math.random()*.6,formTimer:0,formed:false,
                    spawnAngle:Math.random()*Math.PI*2,
                    spawnDist:25+Math.random()*45,
                    spawnH:(Math.random()-.5)*35,
                    shimmer:Math.random()*Math.PI*2,
                    spin:(Math.random()-.5)*.05,rotX:0,rotY:0,
                    pulseOffset:Math.random()*Math.PI*2,
                    // Store local model-space coords for repositioning
                    localX:pt.x, localY:pt.y, localZ:pt.z
                };
                p.x=p.tx+Math.cos(p.spawnAngle)*p.spawnDist;
                p.y=p.ty+p.spawnH;
                p.z=p.tz+Math.sin(p.spawnAngle)*p.spawnDist;
                P.push(p);gp.push(p);
            }

            // Spiral sparks
            for(let i=0;i<350;i++){
                const a1=Math.random()*Math.PI*2;const a2=(Math.random()-.5)*Math.PI;
                const dist=20+Math.random()*35;
                const sx=wx+Math.cos(a1)*Math.cos(a2)*dist;
                const sy=wy+10+Math.sin(a2)*dist;
                const sz=wz+Math.sin(a1)*Math.cos(a2)*dist;
                const dx=wx-sx,dy=wy+10-sy,dz=wz-sz;
                const dl=Math.sqrt(dx*dx+dy*dy+dz*dz)+.01;
                const sp=1.5+Math.random();
                const tanx=-dz/dl,tanz=dx/dl;
                const c=fxColor();
                addP(sx,sy,sz,dx/dl*sp+tanx*.7,dy/dl*sp,dz/dl*sp+tanz*.7,
                    c.r,c.g,c.b,.2+Math.random()*.2,1.5+Math.random()*1.5,.01,0,'spark');
            }

            // Burst ring
            for(let i=0;i<100;i++){
                const a=(i/100)*Math.PI*2;const sp=2+Math.random()*.8;const c=fxColor();
                addP(wx,wy,wz,Math.cos(a)*sp,(Math.random()-.5)*.3,Math.sin(a)*sp,
                    c.r,c.g,c.b,.35,1.3+Math.random()*.5,.014,.003,'ring');
            }

            // Energy pillar
            for(let i=0;i<120;i++){
                const yy=wy-5+Math.random()*30;const c=fxColor();
                addP(wx+(Math.random()-.5)*2,yy,wz+(Math.random()-.5)*2,
                    (Math.random()-.5)*.15,1.5+Math.random()*2.5,(Math.random()-.5)*.15,
                    c.r,c.g,c.b,.12+Math.random()*.12,1+Math.random(),.013,-.012,'beam');
            }

            screenShake(10);doFlash('spawn');

            const g={id,center:new THREE.Vector3(wx,wy+10,wz),particles:gp,
                state:'forming',timer:0,pulsePhase:0,emberTimer:0,orbitAngle:0,intensity:0,
                worldAngle:angle, worldX:wx, worldY:wy, worldZ:wz};
            groups.push(g);
            return g;
        }

        function updateFingerPosition(group, wx,wy,wz, angle){
            // Smoothly move all particle targets to new hand position
            const cosA=Math.cos(angle),sinA=Math.sin(angle);
            group.worldX+=(wx-group.worldX)*.15;
            group.worldY+=(wy-group.worldY)*.15;
            group.worldZ+=(wz-group.worldZ)*.15;
            group.worldAngle+=(angle-group.worldAngle)*.1;

            const ca=Math.cos(group.worldAngle),sa=Math.sin(group.worldAngle);

            for(const p of group.particles){
                if(p.life<=0)continue;
                const rx=p.localX*ca-p.localY*sa;
                const ry=p.localX*sa+p.localY*ca;
                p.tx=group.worldX+rx;
                p.ty=group.worldY+ry;
                p.tz=group.worldZ+p.localZ;
            }
            group.center.set(group.worldX, group.worldY+10, group.worldZ);
        }

        function explodeGroup(group){
            if(group.state==='exploding'||group.state==='dead')return;
            group.state='exploding';group.timer=0;
            const cx=group.center.x,cy=group.center.y,cz=group.center.z;
            screenShake(25);doFlash('explode');

            for(const p of group.particles){
                if(p.life<=0)continue;
                p.type='imploding';
                const dx=cx-p.x,dy=cy-p.y,dz=cz-p.z;
                const dl=Math.sqrt(dx*dx+dy*dy+dz*dz)+.01;
                p.vx=dx/dl*3;p.vy=dy/dl*3;p.vz=dz/dl*3;
                p.grav=0;p.decay=0;p.maxLife=p.life=.25+Math.random()*.1;
                p.r=1;p.g=1;p.b=.9;
            }

            setTimeout(()=>{
                screenShake(35);doFlash('explode');

                for(let wave=0;wave<4;wave++){
                    const count=220-wave*40;
                    for(let i=0;i<count;i++){
                        const a1=Math.random()*Math.PI*2;const a2=(Math.random()-.5)*Math.PI;
                        const sp=(2+wave*1.2)+Math.random()*(4-wave*.5);const c=fxColor();
                        addP(cx+(Math.random()-.5)*3,cy+(Math.random()-.5)*3,cz+(Math.random()-.5)*3,
                            Math.cos(a1)*Math.cos(a2)*sp,Math.sin(a2)*sp+Math.random(),Math.sin(a1)*Math.cos(a2)*sp,
                            c.r,c.g,c.b,.2+Math.random()*.4,2+Math.random()*3,.006+Math.random()*.005,.012+Math.random()*.008,'debris');
                    }
                }

                for(let ring=0;ring<3;ring++){
                    const n=90-ring*20;const sp=3+ring*2;
                    for(let i=0;i<n;i++){const a=(i/n)*Math.PI*2;const c=fxColor();
                        addP(cx,cy+ring*3-3,cz,Math.cos(a)*sp,(Math.random()-.5)*.3,Math.sin(a)*sp,
                            c.r,c.g,c.b,.45-ring*.1,1+Math.random()*.5,.018,0,'ring');}
                }

                for(let i=0;i<180;i++){const c=fxColor();
                    addP(cx+(Math.random()-.5)*6,cy-5+Math.random()*8,cz+(Math.random()-.5)*6,
                        (Math.random()-.5)*1,3+Math.random()*5,(Math.random()-.5)*1,
                        c.r,c.g,c.b,.15+Math.random()*.2,1.5+Math.random()*2.5,.008,-.01,'fire');}

                for(let i=0;i<120;i++){const a=Math.random()*Math.PI*2;const dist=Math.random()*18;const c=fxColor();
                    addP(cx+Math.cos(a)*dist,cy+8+Math.random()*18,cz+Math.sin(a)*dist,
                        (Math.random()-.5)*.4,-.3-Math.random()*.6,(Math.random()-.5)*.4,
                        c.r,c.g,c.b,.1+Math.random()*.08,4+Math.random()*4,.003,.008,'ember');}

                for(let i=0;i<80;i++){const a=Math.random()*Math.PI*2;const sp=1+Math.random()*3;const c=fxColor();
                    addP(cx+Math.cos(a)*2,cy-8,cz+Math.sin(a)*2,Math.cos(a)*sp,1+Math.random()*2.5,Math.sin(a)*sp,
                        c.r,c.g,c.b,.12+Math.random()*.08,1.5+Math.random()*1.5,.012,.025,'gspark');}

                for(let i=0;i<60;i++){const a=Math.random()*Math.PI*2;const sp=.3+Math.random();
                    addP(cx+Math.cos(a)*5,cy+(Math.random()-.5)*10,cz+Math.sin(a)*5,
                        Math.cos(a)*sp,.5+Math.random(),Math.sin(a)*sp,
                        .12,.04,.02,.5+Math.random()*.5,3+Math.random()*3,.005,-.003,'smoke');}

                for(let i=0;i<30;i++){const a=Math.random()*Math.PI*2;const el=(Math.random()-.5)*Math.PI;const sp=5+Math.random()*5;
                    addP(cx,cy,cz,Math.cos(a)*Math.cos(el)*sp,Math.sin(el)*sp,Math.sin(a)*Math.cos(el)*sp,
                        1,.9,.8,.15,.5+Math.random()*.3,.035,.02,'flashspark');}
            },280);
        }

        // â”€â”€ CAMERA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let camTarget=new THREE.Vector3(0,8,0);
        let camGoalPos=new THREE.Vector3(0,14,40);
        let lastDetect=0;
        let camSwayPhase=0;

        // â”€â”€ HAND DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let detected=false;
        let wasDetected=false;
        let detectFrames=0,lostFrames=0;

        const HC=[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];

        function drawDebug(lm,isMF){
            const w=dbgCanvas.width,h=dbgCanvas.height;
            for(const[i,j]of HC){
                const isMid=[9,10,11,12].includes(i)&&[9,10,11,12].includes(j);
                dbgCtx.beginPath();dbgCtx.moveTo(lm[i].x*w,lm[i].y*h);dbgCtx.lineTo(lm[j].x*w,lm[j].y*h);
                if(isMF&&isMid){dbgCtx.strokeStyle='#ff2020';dbgCtx.lineWidth=3;dbgCtx.shadowColor='#ff2020';dbgCtx.shadowBlur=8}
                else{dbgCtx.strokeStyle=isMF?'#22dd44':'#444';dbgCtx.lineWidth=1.5;dbgCtx.shadowBlur=0}
                dbgCtx.stroke();dbgCtx.shadowBlur=0;
            }
            for(let i=0;i<lm.length;i++){
                const m=[9,10,11,12].includes(i);
                dbgCtx.beginPath();dbgCtx.arc(lm[i].x*w,lm[i].y*h,m&&isMF?5:2.5,0,Math.PI*2);
                dbgCtx.fillStyle=isMF?(m?'#ff2020':'#22dd44'):'#333';dbgCtx.fill();
            }
            if(isMF){dbgCtx.fillStyle='#ff2020';dbgCtx.font='bold 11px monospace';dbgCtx.fillText('ðŸ–• DETECTED',6,16)}
        }

        function checkMF(lm){
            const w=lm[0];
            const d3=(a,b)=>Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2+((a.z||0)-(b.z||0))**2);
            const palm={x:(lm[0].x+lm[5].x+lm[9].x+lm[13].x+lm[17].x)/5,
                y:(lm[0].y+lm[5].y+lm[9].y+lm[13].y+lm[17].y)/5,
                z:((lm[0].z||0)+(lm[5].z||0)+(lm[9].z||0)+(lm[13].z||0)+(lm[17].z||0))/5};
            function ext(t,d,p,m){return d3(t,w)>d3(m,w)*1.1&&d3(t,palm)>d3(m,palm)*1.15&&d3(t,m)>d3(p,m)*1.4}
            function curl(t,d,p,m){return d3(t,w)<d3(m,w)*1.15||d3(t,palm)<d3(m,palm)*.95||d3(t,m)<d3(p,m)*1.2}
            const mE=ext(lm[12],lm[11],lm[10],lm[9]);
            const iC=curl(lm[8],lm[7],lm[6],lm[5]);
            const rC=curl(lm[16],lm[15],lm[14],lm[13]);
            const pC=curl(lm[20],lm[19],lm[18],lm[17]);
            const mL=d3(lm[12],lm[9]);
            const dom=mL>d3(lm[8],lm[5])*1.2&&mL>d3(lm[16],lm[13])*1.2&&mL>d3(lm[20],lm[17])*1.2;
            return mE&&iC&&rC&&pC&&dom;
        }

        function getHandData(lm){
            // Get rotation: angle from wrist (0) to middle finger MCP (9)
            const dx=lm[9].x-lm[0].x;
            const dy=lm[9].y-lm[0].y;
            // In screen space, up is -y. We want angle where 0 = finger pointing up
            let angle=Math.atan2(-dx,-dy); // negative because screen Y is flipped

            // Hand size for depth estimation
            const handSize=Math.sqrt(dx*dx+dy*dy);
            const depth=Math.max(.5,Math.min(2,handSize*3));

            // Palm center
            const pcx=(lm[0].x+lm[5].x+lm[9].x+lm[13].x+lm[17].x)/5;
            const pcy=(lm[0].y+lm[5].y+lm[9].y+lm[13].y+lm[17].y)/5;

            return{
                nx:1-pcx, ny:pcy, // mirror X
                angle:angle,
                depth:depth,
                palmNx:1-pcx, palmNy:pcy
            };
        }

        const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${f}`});
        hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:.65,minTrackingConfidence:.5});
        hands.onResults(res=>{
            dbgCtx.clearRect(0,0,dbgCanvas.width,dbgCanvas.height);
            dbgCtx.globalAlpha=.2;dbgCtx.drawImage(res.image,0,0,dbgCanvas.width,dbgCanvas.height);dbgCtx.globalAlpha=1;
            let raw=false;
            if(res.multiHandLandmarks){
                for(const lm of res.multiHandLandmarks){
                    const is=checkMF(lm);
                    drawDebug(lm,is);
                    if(is){
                        raw=true;
                        handData=getHandData(lm);
                        handData.detected=true;
                    }
                }
            }
            if(raw){detectFrames++;lostFrames=0}else{lostFrames++;detectFrames=0}
            if(detectFrames>=3)detected=true;
            if(lostFrames>=8)detected=false;
            statusEl.textContent=detected?'ðŸ–• MIDDLE FINGER DETECTED':'Show your middle finger ðŸ–•';
            statusEl.className=detected?'active':'';
        });

        async function startCam(){
            try{const s=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480,facingMode:'user'}});
                video.srcObject=s;new Camera(video,{onFrame:async()=>await hands.send({image:video}),width:640,height:480}).start();
                loadingScreen.style.display='none';
            }catch(e){loadingScreen.innerHTML='<p style="color:#f55">Camera denied</p>'}
        }

        // â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let prev=performance.now();let globalTime=0;

        function loop(){
            requestAnimationFrame(loop);
            const now=performance.now();const dt=Math.min((now-prev)/1000,.05);prev=now;
            globalTime+=dt;camSwayPhase+=dt;

            // â”€â”€ Handle detection / tracking â”€â”€
            if(detected){
                const wp=normToWorld(handData.nx,handData.ny,handData.depth);
                const wx=wp.x,wy=wp.y,wz=wp.z;
                const angle=handData.angle;

                if(!activeGroup||activeGroup.state==='dead'||activeGroup.state==='exploding'){
                    // Spawn new
                    activeGroup=spawnFinger(wx,wy,wz,angle);
                    lastDetect=now;
                    camTarget.set(wx,wy+10,wz);
                }else{
                    // Update position to follow hand
                    updateFingerPosition(activeGroup, wx,wy,wz, angle);
                    lastDetect=now;
                    camTarget.lerp(activeGroup.center,.08);
                }
                wasDetected=true;
            }else{
                if(wasDetected&&activeGroup&&activeGroup.state!=='exploding'&&activeGroup.state!=='dead'){
                    explodeGroup(activeGroup);
                }
                wasDetected=false;
            }

            // â”€â”€ Update groups â”€â”€
            for(let gi=groups.length-1;gi>=0;gi--){
                const g=groups[gi];g.timer+=dt;

                if(g.state==='forming'){
                    let allDone=true;
                    for(const p of g.particles){
                        if(p.life<=0)continue;p.formTimer+=dt;
                        if(p.formTimer<p.formDelay){allDone=false;continue}
                        const t=Math.min(1,(p.formTimer-p.formDelay)*1.8);
                        const ease=t===0?0:t===1?1:Math.pow(2,-10*t)*Math.sin((t*10-.75)*(2*Math.PI)/3)+1;
                        p.x=p.tx+(Math.cos(p.spawnAngle)*p.spawnDist)*(1-ease);
                        p.y=p.ty+p.spawnH*(1-ease);
                        p.z=p.tz+(Math.sin(p.spawnAngle)*p.spawnDist)*(1-ease);
                        p.formed=ease>=.98;
                        p.size=(.7+Math.random()*.05)*Math.min(1,ease*1.5);
                        if(!p.formed)allDone=false;
                        if(Math.random()<.04&&P.length<MAX-200){const c=fxColor();
                            addP(p.x,p.y,p.z,(Math.random()-.5)*.4,(Math.random()-.5)*.4,(Math.random()-.5)*.4,
                                c.r,c.g,c.b,.12,.4+Math.random()*.4,.03,0,'trail');}
                    }
                    g.intensity=Math.min(1,g.timer*1.5);
                    if(allDone||g.timer>2){
                        g.state='alive';screenShake(6);doFlash('spawn');
                        const c=g.center;
                        for(let i=0;i<60;i++){const a=(i/60)*Math.PI*2;const col=fxColor();
                            addP(c.x,c.y,c.z,Math.cos(a)*1.8,(Math.random()-.5)*.5,Math.sin(a)*1.8,
                                col.r,col.g,col.b,.3,.6+Math.random()*.3,.025,0,'ring')}
                    }
                }

                if(g.state==='alive'){
                    g.pulsePhase+=dt*3;g.emberTimer+=dt;g.orbitAngle+=dt*1.5;g.intensity=1;
                    for(const p of g.particles){
                        if(p.life<=0||!p.formed)continue;p.shimmer+=dt*3.5;
                        const pulse=Math.sin(g.pulsePhase+p.pulseOffset)*.15;
                        const wave=Math.sin(p.shimmer*.7+p.ty*.3)*.08;
                        p.r=Math.min(1,p.baseR+pulse*.3+.05);
                        p.g=Math.min(1,p.baseG+pulse*.5+wave*.3);
                        p.b=Math.min(1,p.baseB+pulse*.2+wave*.15);
                        const breathe=Math.sin(g.pulsePhase*.4)*.15;
                        // Smooth movement toward target
                        p.x+=(p.tx-p.x)*.12+Math.sin(p.shimmer*.5)*.06;
                        p.y+=(p.ty-p.y)*.12+Math.sin(p.shimmer*.35+1)*.06+breathe*.02;
                        p.z+=(p.tz-p.z)*.12+Math.sin(p.shimmer*.6+2)*.06;
                        p.size=.72+Math.sin(p.shimmer+p.pulseOffset)*.1;
                    }
                    if(g.emberTimer>.04){
                        g.emberTimer=0;const c=g.center;
                        for(let i=0;i<3;i++){if(P.length>=MAX-50)break;const col=fxColor();
                            addP(c.x+(Math.random()-.5)*9,c.y-10+Math.random()*22,c.z+(Math.random()-.5)*5,
                                (Math.random()-.5)*.2,.4+Math.random()*.5,(Math.random()-.5)*.2,
                                col.r,col.g,col.b,.08+Math.random()*.06,2+Math.random()*2,.006,-.003,'ember')}
                    }
                    if(P.length<MAX-10){
                        const c=g.center;const oa=g.orbitAngle;
                        const or2=7+Math.sin(globalTime*2)*2;const col=fxColor();
                        addP(c.x+Math.cos(oa)*or2,c.y+Math.sin(globalTime*3)*4,c.z+Math.sin(oa)*or2,
                            -Math.sin(oa)*.25,(Math.random()-.5)*.1,Math.cos(oa)*.25,
                            col.r,col.g,col.b,.08,.25+Math.random()*.15,.04,0,'orbit');
                    }
                }

                if(g.state==='exploding'){
                    g.intensity=Math.max(0,g.intensity-dt*2);
                    let any=false;for(const p of g.particles){if(p.life>0){any=true;break}}
                    if(!any&&g.timer>5)g.state='dead';
                }
                if(g.state==='dead')groups.splice(gi,1);

                if(g===activeGroup){
                    fingerLight.position.lerp(g.center,dt*5);
                    fingerLightTarget=g.intensity*3;
                }
            }

            fingerLight.intensity+=(fingerLightTarget-fingerLight.intensity)*dt*5;
            if(!activeGroup||activeGroup.state==='dead')fingerLightTarget=0;

            const hasActive=activeGroup&&(activeGroup.state==='alive'||activeGroup.state==='forming');
            compMat.uniforms.bloomStrength.value+=((hasActive?2:.8)-compMat.uniforms.bloomStrength.value)*dt*3;

            // Camera: front-facing, follows hand
            const idle=now-lastDetect>6000;
            const sway=Math.sin(camSwayPhase*.25)*2;
            const swayY=Math.sin(camSwayPhase*.18)*.6;
            if(idle){
                camTarget.lerp(new THREE.Vector3(0,5,0),dt*.3);
                camGoalPos.set(camTarget.x+sway,camTarget.y+14+swayY,camTarget.z+38);
            }else{
                camGoalPos.set(camTarget.x+sway,camTarget.y+5+swayY,camTarget.z+35);
            }
            camera.position.lerp(camGoalPos,dt*3);

            shakeAmount*=.9;if(shakeAmount<.01)shakeAmount=0;
            const st=camTarget.clone();
            st.x+=(Math.random()-.5)*shakeAmount;
            st.y+=(Math.random()-.5)*shakeAmount;
            camera.lookAt(st);

            // â”€â”€ Update all particles â”€â”€
            let alive=0;
            for(let i=P.length-1;i>=0;i--){
                const p=P[i];
                if(p.type==='finger'){/* group logic */}
                else if(p.type==='imploding'){
                    p.x+=p.vx*dt*60;p.y+=p.vy*dt*60;p.z+=p.vz*dt*60;
                    p.life-=dt;if(p.life<=0)p.life=0;p.size=.6*(p.life/p.maxLife);
                }else if(p.type==='exploding'){
                    p.x+=p.vx;p.y+=p.vy;p.z+=p.vz;p.vy-=p.grav;
                    p.vx*=.97;p.vy*=.97;p.vz*=.97;p.life-=p.decay;
                    const f=p.life/p.maxLife;p.r=1;p.g=Math.max(0,f*.7);p.b=Math.max(0,f*.4-.1);
                    p.rotX+=p.spin;p.rotY+=p.spin*1.3;
                }else{
                    p.x+=p.vx;p.y+=p.vy;p.z+=p.vz;p.vy-=p.grav;
                    p.vx*=.995;p.vz*=.995;p.life-=p.decay;
                    p.rotX+=p.spin;p.rotY+=p.spin*.7;
                }
                if(p.life<=0){P.splice(i,1);continue}

                const f=p.type==='finger'?1:Math.max(0,p.life/p.maxLife);
                const s=p.size*(p.type==='finger'?1:(.15+f*.85));
                dum.position.set(p.x,p.y,p.z);
                dum.scale.setScalar(Math.max(.01,s));
                dum.rotation.set(p.rotX||0,p.rotY||0,0);
                dum.updateMatrix();
                imesh.setMatrixAt(alive,dum.matrix);
                const cr=p.type==='finger'?p.r:p.r*f;
                const cg=p.type==='finger'?p.g:p.g*f;
                const cb=p.type==='finger'?p.b:p.b*f;
                tc.setRGB(Math.min(1,cr),Math.min(1,cg),Math.min(1,cb));
                imesh.setColorAt(alive,tc);
                alive++;
            }

            if(alive<imesh.count){
                dum.position.set(0,-999,0);dum.scale.setScalar(0);dum.updateMatrix();
                for(let i=alive;i<imesh.count;i++)imesh.setMatrixAt(i,dum.matrix);
            }
            imesh.count=alive;
            imesh.instanceMatrix.needsUpdate=true;
            if(imesh.instanceColor)imesh.instanceColor.needsUpdate=true;

            renderBloom();
        }

        loop();startCam();
    })();
    </script>
</body>
</html>
