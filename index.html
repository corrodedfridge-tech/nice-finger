<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Middle Finger Particles</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
        canvas { display: block; }
        #video {
            position: fixed; bottom: 15px; right: 15px; width: 200px; height: 150px;
            border: 1px solid #222; border-radius: 8px; z-index: 20;
            transform: scaleX(-1); object-fit: cover; opacity: 0.85;
        }
        #debugCanvas {
            position: fixed; bottom: 15px; left: 15px; width: 200px; height: 150px;
            border: 1px solid #333; border-radius: 8px; z-index: 20; background: #000;
        }
        #status {
            position: fixed; top: 15px; left: 50%; transform: translateX(-50%);
            color: #555; font-size: 13px; z-index: 30; text-align: center;
            background: rgba(0,0,0,0.85); padding: 8px 18px; border-radius: 20px;
            border: 1px solid #222; letter-spacing: 0.5px; transition: all 0.3s;
        }
        #status.active { color: #ff2020; border-color: #ff2020; box-shadow: 0 0 25px rgba(255,30,30,0.4); }
        #flash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(255,30,30,0.3), transparent 70%);
            pointer-events: none; z-index: 5; opacity: 0; transition: opacity 0.1s;
        }
        #flash.on { opacity: 1; transition: opacity 0.05s; }
        .loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #666; font-size: 16px; z-index: 100; text-align: center;
        }
        .spinner {
            border: 2px solid #1a1a1a; border-top: 2px solid #ff2020; border-radius: 50%;
            width: 32px; height: 32px; animation: s .8s linear infinite; margin: 12px auto;
        }
        @keyframes s { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loadingScreen" class="loading"><div class="spinner"></div><p>Loading hand tracking...</p></div>
    <div id="flash"></div>
    <video id="video" autoplay playsinline></video>
    <canvas id="debugCanvas"></canvas>
    <div id="status">Show your middle finger ðŸ–•</div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    (function () {
        const video = document.getElementById('video');
        const statusEl = document.getElementById('status');
        const loadingScreen = document.getElementById('loadingScreen');
        const flashEl = document.getElementById('flash');
        const dbgCanvas = document.getElementById('debugCanvas');
        const dbgCtx = dbgCanvas.getContext('2d');
        dbgCanvas.width = 320; dbgCanvas.height = 240;

        // Screen shake
        let shakeAmount = 0;
        let shakeDecay = 0.92;

        function screenShake(amount) { shakeAmount = Math.max(shakeAmount, amount); }
        function flash() {
            flashEl.classList.add('on');
            setTimeout(() => flashEl.classList.remove('on'), 120);
        }

        // THREE
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 600);
        camera.position.set(0, 18, 50);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(1);
        renderer.shadowMap.enabled = false;
        document.body.prepend(renderer.domElement);
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth/innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        scene.add(new THREE.AmbientLight(0xffffff, 1));

        // Instanced cubes
        const GEO = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        const MAT = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const MAX = 30000;
        const imesh = new THREE.InstancedMesh(GEO, MAT, MAX);
        imesh.count = 0;
        scene.add(imesh);
        const dum = new THREE.Object3D();
        const tc = new THREE.Color();

        const P = [];
        function addP(x,y,z,vx,vy,vz,r,g,b,size,life,decay,grav,type) {
            if (P.length >= MAX) return;
            P.push({x,y,z,vx,vy,vz,r,g,b,size,life,maxLife:life,decay,grav,type:type||'fx',
                    groupId:-1, spin:(Math.random()-0.5)*0.1, rotX:Math.random()*6.28, rotY:Math.random()*6.28});
        }

        // â”€â”€ BUILD MIDDLE FINGER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function buildFinger() {
            const pts = [];
            function cyl(cx,cy,cz,rad,h,step,seg) {
                for (let y=0;y<h;y+=step) {
                    for (let i=0;i<seg;i++) {
                        const a=(i/seg)*Math.PI*2;
                        pts.push({x:cx+Math.cos(a)*rad, y:cy+y, z:cz+Math.sin(a)*rad});
                    }
                    // inner ring for thickness
                    if (y % (step*2) < step) {
                        for (let i=0;i<seg-2;i++) {
                            const a=(i/(seg-2))*Math.PI*2;
                            pts.push({x:cx+Math.cos(a)*rad*0.5, y:cy+y, z:cz+Math.sin(a)*rad*0.5});
                        }
                    }
                }
            }
            function hemi(cx,cy,cz,rad,seg) {
                for (let p=0;p<Math.PI/2;p+=0.25) {
                    const r=rad*Math.cos(p);
                    const n=Math.max(3,Math.round(seg*Math.cos(p)));
                    for (let i=0;i<n;i++) {
                        const a=(i/n)*Math.PI*2;
                        pts.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(p)*rad, z:cz+Math.sin(a)*r});
                    }
                }
                pts.push({x:cx,y:cy+rad,z:cz});
            }
            function box(cx,cy,cz,w,h,d,step) {
                for (let y=0;y<=h;y+=step) {
                    for (let x=-w/2;x<=w/2;x+=step) {
                        pts.push({x:cx+x,y:cy+y,z:cz+d/2});
                        pts.push({x:cx+x,y:cy+y,z:cz-d/2});
                    }
                    for (let z=-d/2;z<=d/2;z+=step) {
                        pts.push({x:cx-w/2,y:cy+y,z:cz+z});
                        pts.push({x:cx+w/2,y:cy+y,z:cz+z});
                    }
                }
                for (let x=-w/2;x<=w/2;x+=step)
                    for (let z=-d/2;z<=d/2;z+=step) {
                        pts.push({x:cx+x,y:cy,z:cz+z});
                        pts.push({x:cx+x,y:cy+h,z:cz+z});
                    }
            }

            // Middle finger
            cyl(0, 5.5, 0, 1.15, 14.5, 0.5, 10);
            hemi(0, 20, 0, 1.15, 10);

            // Fist
            box(0, 0, 0, 8.5, 5.5, 3.5, 0.7);
            // fist fill
            for (let y=0.5;y<5;y+=1.4) for (let x=-3;x<=3;x+=1.6) pts.push({x,y,z:0});

            // Curled fingers
            for (const fx of [-3.0,-1.0,1.0,3.0]) {
                for (let t=0;t<=1;t+=0.07) {
                    const a=t*Math.PI*0.75;
                    const cy=5.5+Math.sin(a)*1.5;
                    const cz=Math.cos(a)*1.5-0.5;
                    for (let i=0;i<5;i++) {
                        const ang=(i/5)*Math.PI*2;
                        pts.push({x:fx+Math.cos(ang)*0.5,y:cy+Math.sin(ang)*0.55,z:cz});
                    }
                }
            }

            // Thumb
            for (let t=0;t<=1;t+=0.05) {
                const tx=4.75+Math.sin(t*1.2)*1.5;
                const ty=0.8+t*3.8;
                const tz=1.75*(1-t*0.6)+0.5;
                for (let i=0;i<5;i++) {
                    const a=(i/5)*Math.PI*2;
                    pts.push({x:tx+Math.cos(a)*0.6,y:ty,z:tz+Math.sin(a)*0.6});
                }
            }
            hemi(4.75+Math.sin(1.2)*1.5, 4.6, 1.75*0.4+0.5, 0.6, 4);

            // Wrist
            for (let y=-3;y<0;y+=0.6) {
                const s=1+y*0.04;
                for (let x=-4.25*s;x<=4.25*s;x+=0.8) {
                    pts.push({x,y,z:1.75*s});
                    pts.push({x,y,z:-1.75*s});
                }
            }
            return pts;
        }

        const FPTS = buildFinger();
        let groups = [];
        let gid = 0;

        function spawnFinger(wx, wy, wz) {
            const id = gid++;
            const gp = [];

            // Spawn particles from far away, converge in
            for (const pt of FPTS) {
                if (P.length >= MAX - 800) break;
                const h = (pt.y+3)/25;
                // Red hot color palette
                const r = 0.95 + Math.random()*0.05;
                const g = 0.08 + h*0.2 + Math.random()*0.06;
                const b = 0.02 + Math.random()*0.04;

                const p = {
                    x:0, y:0, z:0,
                    tx: wx+pt.x, ty: wy+pt.y, tz: wz+pt.z,
                    vx:0, vy:0, vz:0,
                    r, g, b, baseR:r, baseG:g, baseB:b,
                    size: 0.75 + Math.random()*0.25,
                    life:999, maxLife:999, decay:0, grav:0,
                    type:'finger', groupId:id,
                    formDelay: Math.random()*0.6,
                    formTimer: 0, formed: false,
                    // Start position: spiral inward from distance
                    spawnAngle: Math.random()*Math.PI*2,
                    spawnDist: 25 + Math.random()*35,
                    spawnH: (Math.random()-0.5)*30,
                    shimmer: Math.random()*Math.PI*2,
                    spin: (Math.random()-0.5)*0.05,
                    rotX: 0, rotY: 0
                };
                // Set initial scattered position
                p.x = p.tx + Math.cos(p.spawnAngle)*p.spawnDist;
                p.y = p.ty + p.spawnH;
                p.z = p.tz + Math.sin(p.spawnAngle)*p.spawnDist;
                P.push(p);
                gp.push(p);
            }

            // Inward streaking sparks
            for (let i=0;i<300;i++) {
                const a1=Math.random()*Math.PI*2;
                const a2=(Math.random()-0.5)*Math.PI;
                const dist=20+Math.random()*30;
                const sx=wx+Math.cos(a1)*Math.cos(a2)*dist;
                const sy=wy+10+Math.sin(a2)*dist;
                const sz=wz+Math.sin(a1)*Math.cos(a2)*dist;
                const dx=wx-sx, dy=wy+10-sy, dz=wz-sz;
                const dl=Math.sqrt(dx*dx+dy*dy+dz*dz)+0.01;
                const sp=1.2+Math.random()*0.8;
                addP(sx,sy,sz, dx/dl*sp,dy/dl*sp,dz/dl*sp,
                    1,0.15+Math.random()*0.2,0.02+Math.random()*0.05,
                    0.3+Math.random()*0.25, 1.2+Math.random()*1.5, 0.012, 0, 'spark');
            }

            // Ground impact ring
            for (let i=0;i<100;i++) {
                const a=(i/100)*Math.PI*2;
                const sp=1.5+Math.random()*0.5;
                addP(wx,wy-2,wz,
                    Math.cos(a)*sp, 0.1+Math.random()*0.3, Math.sin(a)*sp,
                    1,0.2,0.02,
                    0.3, 1.5+Math.random(), 0.015, 0.008, 'ring');
            }

            // Vertical energy beam
            for (let i=0;i<80;i++) {
                const yy = wy-5 + Math.random()*30;
                addP(wx+(Math.random()-0.5)*1.5, yy, wz+(Math.random()-0.5)*1.5,
                    (Math.random()-0.5)*0.1, 1+Math.random()*2, (Math.random()-0.5)*0.1,
                    1,0.3+Math.random()*0.2,0.05,
                    0.2+Math.random()*0.15, 1+Math.random()*1, 0.015, -0.01, 'beam');
            }

            screenShake(8);
            flash();

            groups.push({
                id, center: new THREE.Vector3(wx,wy+10,wz),
                particles: gp, state:'forming', timer:0, aliveTime:0,
                pulsePhase: 0, emberTimer: 0
            });

            return new THREE.Vector3(wx, wy+10, wz);
        }

        function explodeGroup(group) {
            if (group.state==='exploding'||group.state==='dead') return;
            group.state = 'exploding';
            group.timer = 0;

            const cx=group.center.x, cy=group.center.y, cz=group.center.z;

            screenShake(15);
            flash();

            // Convert finger particles to shrapnel
            for (const p of group.particles) {
                if (p.life<=0) continue;
                p.type = 'exploding';
                const dx=p.x-cx, dy=p.y-cy, dz=p.z-cz;
                const dl=Math.sqrt(dx*dx+dy*dy+dz*dz)+0.01;
                const force = 2+Math.random()*4;
                p.vx = (dx/dl)*force + (Math.random()-0.5)*2;
                p.vy = (dy/dl)*force + Math.random()*2;
                p.vz = (dz/dl)*force + (Math.random()-0.5)*2;
                p.grav = 0.03+Math.random()*0.02;
                p.decay = 0.006+Math.random()*0.006;
                p.maxLife = p.life = 2.5+Math.random()*2.5;
                p.r=1; p.g=0.9; p.b=0.7; // flash white-hot
                p.spin = (Math.random()-0.5)*0.5;
            }

            // Massive explosion burst - multiple waves
            for (let wave=0; wave<3; wave++) {
                const delay = wave * 0.1;
                const count = 200 - wave*50;
                for (let i=0;i<count;i++) {
                    const a1=Math.random()*Math.PI*2;
                    const a2=(Math.random()-0.5)*Math.PI;
                    const sp=(1+wave*0.5)+Math.random()*(3-wave*0.5);
                    const px=cx+(Math.random()-0.5)*3;
                    const py=cy+(Math.random()-0.5)*3;
                    const pz=cz+(Math.random()-0.5)*3;
                    addP(px,py,pz,
                        Math.cos(a1)*Math.cos(a2)*sp,
                        Math.sin(a2)*sp+Math.random()*0.5,
                        Math.sin(a1)*Math.cos(a2)*sp,
                        1, 0.1+Math.random()*0.25, 0.02+Math.random()*0.05,
                        0.25+Math.random()*0.35, 2+Math.random()*2, 0.008+Math.random()*0.006,
                        0.015+Math.random()*0.01, 'debris');
                }
            }

            // Shockwave rings - multiple expanding
            for (let ring=0; ring<3; ring++) {
                const n = 80 - ring*20;
                const sp = 2.5 + ring*1.5;
                for (let i=0;i<n;i++) {
                    const a=(i/n)*Math.PI*2;
                    addP(cx,cy+ring*2-2,cz,
                        Math.cos(a)*sp, (Math.random()-0.5)*0.2, Math.sin(a)*sp,
                        1, 0.15+ring*0.05, 0.02,
                        0.4-ring*0.1, 1.2+Math.random()*0.5, 0.02, 0, 'ring');
                }
            }

            // Upward fire column
            for (let i=0;i<120;i++) {
                addP(cx+(Math.random()-0.5)*5, cy-3+Math.random()*5, cz+(Math.random()-0.5)*5,
                    (Math.random()-0.5)*0.8, 2+Math.random()*4, (Math.random()-0.5)*0.8,
                    1, 0.4+Math.random()*0.3, 0.05+Math.random()*0.05,
                    0.2+Math.random()*0.2, 1.5+Math.random()*2, 0.01, -0.008, 'fire');
            }

            // Falling embers
            for (let i=0;i<80;i++) {
                const a=Math.random()*Math.PI*2;
                const dist=Math.random()*15;
                addP(cx+Math.cos(a)*dist, cy+5+Math.random()*15, cz+Math.sin(a)*dist,
                    (Math.random()-0.5)*0.3, -0.2-Math.random()*0.5, (Math.random()-0.5)*0.3,
                    1, 0.15+Math.random()*0.15, 0.01,
                    0.15+Math.random()*0.1, 3+Math.random()*3, 0.005, 0.01, 'ember');
            }

            // Ground sparks
            for (let i=0;i<60;i++) {
                const a=Math.random()*Math.PI*2;
                const sp=0.5+Math.random()*2;
                addP(cx+Math.cos(a)*3, cy-8, cz+Math.sin(a)*3,
                    Math.cos(a)*sp, 0.5+Math.random()*1.5, Math.sin(a)*sp,
                    1, 0.3, 0.02,
                    0.15+Math.random()*0.1, 1+Math.random()*1.5, 0.015, 0.02, 'gspark');
            }
        }

        // Camera
        let camTarget = new THREE.Vector3(0,8,0);
        let camGoalPos = new THREE.Vector3(0,18,50);
        let camAngle = 0;
        let lastDetect = 0;
        let camShakeX=0, camShakeY=0;

        function aimCamera(target) {
            camAngle = Math.atan2(camera.position.x-target.x, camera.position.z-target.z);
            camGoalPos.set(
                target.x+Math.sin(camAngle)*32,
                target.y+12,
                target.z+Math.cos(camAngle)*32
            );
            camTarget.copy(target);
            lastDetect = performance.now();
        }

        // â”€â”€ HAND DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let detected = false;
        let fingerNorm = {x:0.5,y:0.5};
        let spawnCD = 0;
        let wasDetected = false;
        let detectFrames = 0;
        let lostFrames = 0;

        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]
        ];

        function drawDebug(lm, isMF) {
            const w=dbgCanvas.width, h=dbgCanvas.height;
            for (const [i,j] of HAND_CONNECTIONS) {
                const isMid=[9,10,11,12].includes(i)&&[9,10,11,12].includes(j);
                dbgCtx.beginPath();
                dbgCtx.moveTo(lm[i].x*w,lm[i].y*h);
                dbgCtx.lineTo(lm[j].x*w,lm[j].y*h);
                if (isMF&&isMid) { dbgCtx.strokeStyle='#ff2020'; dbgCtx.lineWidth=3; }
                else { dbgCtx.strokeStyle=isMF?'#44ff44':'#444'; dbgCtx.lineWidth=1.5; }
                dbgCtx.stroke();
            }
            for (let i=0;i<lm.length;i++) {
                const isMid=[9,10,11,12].includes(i);
                dbgCtx.beginPath();
                dbgCtx.arc(lm[i].x*w,lm[i].y*h,isMid&&isMF?4:2,0,Math.PI*2);
                dbgCtx.fillStyle=isMF?(isMid?'#ff2020':'#44ff44'):'#333';
                dbgCtx.fill();
            }
            dbgCtx.font='10px monospace';
            dbgCtx.fillStyle=isMF?'#ff2020':'#444';
            dbgCtx.fillText(isMF?'â— MIDDLE FINGER':'â—‹ waiting...',6,14);
        }

        function checkMF(lm) {
            const w=lm[0];
            const d3=(a,b)=>Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2+((a.z||0)-(b.z||0))**2);
            const palm={
                x:(lm[0].x+lm[5].x+lm[9].x+lm[13].x+lm[17].x)/5,
                y:(lm[0].y+lm[5].y+lm[9].y+lm[13].y+lm[17].y)/5,
                z:((lm[0].z||0)+(lm[5].z||0)+(lm[9].z||0)+(lm[13].z||0)+(lm[17].z||0))/5
            };
            function ext(t,d,p,m){
                return d3(t,w)>d3(m,w)*1.1 && d3(t,palm)>d3(m,palm)*1.15 && d3(t,m)>d3(p,m)*1.4;
            }
            function curl(t,d,p,m){
                return d3(t,w)<d3(m,w)*1.15 || d3(t,palm)<d3(m,palm)*0.95 || d3(t,m)<d3(p,m)*1.2;
            }
            const mE=ext(lm[12],lm[11],lm[10],lm[9]);
            const iC=curl(lm[8],lm[7],lm[6],lm[5]);
            const rC=curl(lm[16],lm[15],lm[14],lm[13]);
            const pC=curl(lm[20],lm[19],lm[18],lm[17]);
            const mLen=d3(lm[12],lm[9]);
            const dominant=mLen>d3(lm[8],lm[5])*1.2 && mLen>d3(lm[16],lm[13])*1.2 && mLen>d3(lm[20],lm[17])*1.2;
            return mE&&iC&&rC&&pC&&dominant;
        }

        const hands = new Hands({
            locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${f}`
        });
        hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.65,minTrackingConfidence:0.5});

        hands.onResults(res => {
            dbgCtx.clearRect(0,0,dbgCanvas.width,dbgCanvas.height);
            dbgCtx.globalAlpha=0.2;
            dbgCtx.drawImage(res.image,0,0,dbgCanvas.width,dbgCanvas.height);
            dbgCtx.globalAlpha=1;

            let raw=false;
            if (res.multiHandLandmarks) {
                for (const lm of res.multiHandLandmarks) {
                    const is=checkMF(lm);
                    drawDebug(lm,is);
                    if (is) { raw=true; fingerNorm={x:1-lm[12].x,y:lm[12].y}; }
                }
            }
            if (raw) { detectFrames++; lostFrames=0; }
            else { lostFrames++; detectFrames=0; }
            if (detectFrames>=3) detected=true;
            if (lostFrames>=8) detected=false;
            statusEl.textContent=detected?'ðŸ–• MIDDLE FINGER DETECTED':'Show your middle finger ðŸ–•';
            statusEl.className=detected?'active':'';
        });

        async function startCam() {
            try {
                const s=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480,facingMode:'user'}});
                video.srcObject=s;
                new Camera(video,{
                    onFrame:async()=>await hands.send({image:video}),
                    width:640,height:480
                }).start();
                loadingScreen.style.display='none';
            } catch(e) {
                loadingScreen.innerHTML='<p style="color:#f55">Camera denied</p>';
            }
        }

        // â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let prev=performance.now();
        let activeGroup=null;
        let globalTime=0;

        function loop() {
            requestAnimationFrame(loop);
            const now=performance.now();
            const dt=Math.min((now-prev)/1000,0.05);
            prev=now;
            globalTime+=dt;

            // Spawn / manage
            if (detected) {
                if (!activeGroup||activeGroup.state==='dead'||activeGroup.state==='exploding') {
                    spawnCD-=dt;
                    if (spawnCD<=0) {
                        const wx=(fingerNorm.x-0.5)*50;
                        const wy=(0.5-fingerNorm.y)*35;
                        const wz=0;
                        const t=spawnFinger(wx,wy,wz);
                        activeGroup=groups[groups.length-1];
                        aimCamera(t);
                        spawnCD=0.5;
                    }
                }
                wasDetected=true;
            } else {
                if (wasDetected&&activeGroup&&activeGroup.state!=='exploding'&&activeGroup.state!=='dead') {
                    explodeGroup(activeGroup);
                }
                wasDetected=false;
                spawnCD=0;
            }

            // Update groups
            for (let gi=groups.length-1;gi>=0;gi--) {
                const g=groups[gi];
                g.timer+=dt;

                if (g.state==='forming') {
                    let allDone=true;
                    for (const p of g.particles) {
                        if (p.life<=0) continue;
                        p.formTimer+=dt;
                        if (p.formTimer<p.formDelay) { allDone=false; continue; }
                        const t=Math.min(1,(p.formTimer-p.formDelay)*1.8);
                        // Elastic ease out
                        const ease = t===0?0:t===1?1:Math.pow(2,-10*t)*Math.sin((t*10-0.75)*(2*Math.PI)/3)+1;
                        p.x = p.tx + (Math.cos(p.spawnAngle)*p.spawnDist)*(1-ease);
                        p.y = p.ty + p.spawnH*(1-ease);
                        p.z = p.tz + (Math.sin(p.spawnAngle)*p.spawnDist)*(1-ease);
                        p.formed = ease>=0.98;
                        p.size = (0.75+Math.random()*0.05)*Math.min(1,ease*1.5);
                        if (!p.formed) allDone=false;
                        // Trail sparks while forming
                        if (Math.random()<0.03 && P.length<MAX-100) {
                            addP(p.x,p.y,p.z,
                                (Math.random()-0.5)*0.3,(Math.random()-0.5)*0.3,(Math.random()-0.5)*0.3,
                                1,0.2,0.02, 0.15, 0.5+Math.random()*0.5, 0.025, 0, 'trail');
                        }
                    }
                    if (allDone||g.timer>2.5) {
                        g.state='alive';
                        screenShake(5);
                        // Formation complete burst
                        const c=g.center;
                        for (let i=0;i<50;i++) {
                            const a=(i/50)*Math.PI*2;
                            addP(c.x,c.y,c.z,
                                Math.cos(a)*1.5,(Math.random()-0.5)*0.5,Math.sin(a)*1.5,
                                1,0.25,0.03, 0.3, 0.8+Math.random()*0.5, 0.02, 0, 'ring');
                        }
                    }
                }

                if (g.state==='alive') {
                    g.pulsePhase+=dt*2.5;
                    g.emberTimer+=dt;

                    for (const p of g.particles) {
                        if (p.life<=0) continue;
                        p.shimmer+=dt*3;
                        const pulse=Math.sin(g.pulsePhase)*0.12;
                        const wave=Math.sin(p.shimmer*0.7+p.ty*0.3)*0.06;

                        p.r=Math.min(1,p.baseR+pulse+0.05);
                        p.g=Math.min(1,p.baseG+pulse*0.4+wave*0.3);
                        p.b=Math.min(1,p.baseB+wave*0.2);

                        // Breathing motion
                        const breathe=Math.sin(g.pulsePhase*0.5)*0.15;
                        p.x=p.tx+Math.sin(p.shimmer*0.5)*0.1;
                        p.y=p.ty+Math.sin(p.shimmer*0.4+1)*0.1+breathe;
                        p.z=p.tz+Math.sin(p.shimmer*0.6+2)*0.1;

                        p.size=0.75+Math.sin(p.shimmer)*0.08;
                    }

                    // Continuous ember particles floating off
                    if (g.emberTimer>0.05) {
                        g.emberTimer=0;
                        const c=g.center;
                        for (let i=0;i<3;i++) {
                            if (P.length>=MAX-50) break;
                            const ox=(Math.random()-0.5)*8;
                            const oy=Math.random()*20-3;
                            const oz=(Math.random()-0.5)*4;
                            addP(c.x+ox, c.y+oy-10, c.z+oz,
                                (Math.random()-0.5)*0.15, 0.3+Math.random()*0.5, (Math.random()-0.5)*0.15,
                                1, 0.12+Math.random()*0.1, 0.01,
                                0.12+Math.random()*0.08, 1.5+Math.random()*2, 0.008, -0.002, 'ember');
                        }
                    }
                }

                if (g.state==='exploding') {
                    let any=false;
                    for (const p of g.particles) { if (p.life>0){any=true;break;} }
                    if (!any&&g.timer>4) g.state='dead';
                }
                if (g.state==='dead') groups.splice(gi,1);
            }

            // Camera
            const idle=now-lastDetect>6000;
            if (idle) {
                camAngle+=dt*0.1;
                camGoalPos.set(Math.sin(camAngle)*45,16,Math.cos(camAngle)*45);
                camTarget.lerp(new THREE.Vector3(0,5,0),dt*0.3);
            } else {
                camAngle+=dt*0.15;
                camGoalPos.set(
                    camTarget.x+Math.sin(camAngle)*32,
                    camTarget.y+12,
                    camTarget.z+Math.cos(camAngle)*32
                );
            }
            camera.position.lerp(camGoalPos,dt*2);

            // Screen shake
            shakeAmount*=shakeDecay;
            if (shakeAmount<0.01) shakeAmount=0;
            camShakeX=(Math.random()-0.5)*shakeAmount;
            camShakeY=(Math.random()-0.5)*shakeAmount;
            const shakeTarget=camTarget.clone();
            shakeTarget.x+=camShakeX;
            shakeTarget.y+=camShakeY;
            camera.lookAt(shakeTarget);

            // Update all particles
            let alive=0;
            for (let i=P.length-1;i>=0;i--) {
                const p=P[i];

                if (p.type==='finger') {
                    // handled by group logic above
                } else if (p.type==='exploding') {
                    p.x+=p.vx; p.y+=p.vy; p.z+=p.vz;
                    p.vy-=p.grav;
                    p.vx*=0.97; p.vy*=0.97; p.vz*=0.97;
                    p.life-=p.decay;
                    const f=p.life/p.maxLife;
                    // White hot -> red -> dark
                    p.r=1;
                    p.g=Math.max(0,f*0.8-0.1);
                    p.b=Math.max(0,f*0.5-0.2);
                    p.rotX+=p.spin;
                    p.rotY+=p.spin*1.3;
                } else {
                    p.x+=p.vx; p.y+=p.vy; p.z+=p.vz;
                    p.vy-=p.grav;
                    p.vx*=0.995; p.vz*=0.995;
                    p.life-=p.decay;
                    p.rotX+=p.spin;
                    p.rotY+=p.spin*0.7;
                }

                if (p.life<=0) { P.splice(i,1); continue; }

                const f=p.type==='finger'?1:Math.max(0,p.life/p.maxLife);
                const s=p.size*(p.type==='finger'?1:(0.2+f*0.8));

                dum.position.set(p.x,p.y,p.z);
                dum.scale.setScalar(Math.max(0.01,s));
                dum.rotation.set(p.rotX||0, p.rotY||0, 0);
                dum.updateMatrix();
                imesh.setMatrixAt(alive,dum.matrix);
                tc.setRGB(
                    Math.min(1,p.r*f),
                    Math.min(1,p.g*f),
                    Math.min(1,p.b*f)
                );
                imesh.setColorAt(alive,tc);
                alive++;
            }

            if (alive<imesh.count) {
                dum.position.set(0,-999,0);
                dum.scale.setScalar(0);
                dum.updateMatrix();
                for (let i=alive;i<imesh.count;i++) imesh.setMatrixAt(i,dum.matrix);
            }

            imesh.count=alive;
            imesh.instanceMatrix.needsUpdate=true;
            if (imesh.instanceColor) imesh.instanceColor.needsUpdate=true;

            renderer.render(scene,camera);
        }

        loop();
        startCam();
    })();
    </script>
</body>
</html>
